# Dovie Messenger - 완전한 네이티브 iOS 앱 코드 (Gemini 학습용)

## 프로젝트 개요
Dovie Messenger는 Replit 백엔드 서버(https://dovie-hello2sangyun.replit.app)와 연동되는 완전한 네이티브 iOS 메신저 앱입니다.

### 주요 기능
- 실시간 채팅 (WebSocket 기반)
- 다중 인증 시스템 (이메일/전화번호/Google/Facebook)
- 비즈니스 네트워킹 공간 (LinkedIn 스타일)
- 스마트 파일 아카이브 시스템
- 네이티브 푸시 알림
- 연락처 관리 및 QR 코드 스캔

### 기술 스택
- 언어: Swift 5.0+
- UI 프레임워크: SwiftUI
- 아키텍처: MVVM + Combine
- 네트워킹: URLSession + Combine
- 실시간 통신: URLSessionWebSocketTask
- 보안: Keychain Services
- 푸시 알림: UserNotifications Framework

### 프로젝트 구조
```
DovieMessenger/
├── DovieMessengerApp.swift       # 앱 진입점
├── ContentView.swift             # 메인 탭 네비게이션
├── Info.plist                    # 앱 설정 및 권한
├── Models/                       # 데이터 모델
│   ├── User.swift
│   ├── Message.swift
│   ├── ChatRoom.swift
│   ├── Contact.swift
│   └── BusinessPost.swift
├── Views/                        # UI 컴포넌트
│   ├── AuthenticationView.swift
│   ├── ChatsListView.swift
│   ├── ChatRoomView.swift
│   ├── ContactsView.swift
│   ├── SpaceView.swift
│   ├── ArchiveView.swift
│   └── SettingsView.swift
├── Services/                     # 서비스 레이어
│   ├── AuthenticationManager.swift
│   ├── ChatManager.swift
│   ├── APIService.swift
│   ├── WebSocketService.swift
│   ├── KeychainManager.swift
│   └── PushNotificationManager.swift
├── Utils/                        # 유틸리티
│   ├── Constants.swift
│   ├── NetworkUtils.swift
│   └── DateUtils.swift
└── Extensions/                   # 확장 기능
    ├── View+Extensions.swift
    ├── String+Extensions.swift
    └── Color+Extensions.swift
```

## 완전한 Swift 코드

### 1. 앱 진입점

#### DovieMessengerApp.swift
```swift
//
//  DovieMessengerApp.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import UserNotifications

@main
struct DovieMessengerApp: App {
    @StateObject private var authManager = AuthenticationManager()
    @StateObject private var chatManager = ChatManager()
    @StateObject private var pushManager = PushNotificationManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authManager)
                .environmentObject(chatManager)
                .environmentObject(pushManager)
                .onAppear {
                    setupNotifications()
                }
        }
    }
    
    private func setupNotifications() {
        UNUserNotificationCenter.current().delegate = pushManager
        pushManager.requestPermissions()
    }
}
```

#### ContentView.swift
```swift
//
//  ContentView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    
    var body: some View {
        Group {
            if authManager.isAuthenticated {
                MainTabView()
                    .transition(.opacity)
            } else {
                AuthenticationView()
                    .transition(.opacity)
            }
        }
        .animation(.easeInOut(duration: 0.3), value: authManager.isAuthenticated)
    }
}

struct MainTabView: View {
    var body: some View {
        TabView {
            ChatsListView()
                .tabItem {
                    Image(systemName: "message")
                    Text("채팅")
                }
            
            ContactsView()
                .tabItem {
                    Image(systemName: "person.2")
                    Text("연락처")
                }
            
            SpaceView()
                .tabItem {
                    Image(systemName: "briefcase")
                    Text("스페이스")
                }
            
            ArchiveView()
                .tabItem {
                    Image(systemName: "archivebox")
                    Text("아카이브")
                }
            
            SettingsView()
                .tabItem {
                    Image(systemName: "gear")
                    Text("설정")
                }
        }
        .accentColor(.purple)
    }
}
```

### 2. 데이터 모델

#### Models/User.swift
```swift
//
//  User.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct User: Identifiable, Codable {
    let id: Int
    let username: String
    let displayName: String
    let email: String?
    let phoneNumber: String?
    let profilePicture: String?
    let loginProvider: String?
    let googleId: String?
    let facebookId: String?
    let businessName: String?
    let businessAddress: String?
    let isOnline: Bool?
    let lastSeen: Date?
    let allowVoicePlayback: Bool?
    let autoPlayVoiceMessages: Bool?
    let createdAt: Date
    let updatedAt: Date
    
    var displayUsername: String {
        return "@\(username)"
    }
    
    var initials: String {
        let components = displayName.components(separatedBy: " ")
        let firstInitial = components.first?.prefix(1) ?? ""
        let lastInitial = components.count > 1 ? components.last?.prefix(1) ?? "" : ""
        return "\(firstInitial)\(lastInitial)".uppercased()
    }
}
```

#### Models/Message.swift
```swift
//
//  Message.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct Message: Identifiable, Codable {
    let id: Int
    let chatRoomId: Int
    let senderId: Int
    let content: String?
    let messageType: MessageType
    let isEdited: Bool
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var sender: User?
    var attachments: [MessageAttachment]?
    var reactions: [MessageReaction]?
}

enum MessageType: String, Codable, CaseIterable {
    case text = "text"
    case image = "image"
    case video = "video"
    case audio = "audio"
    case file = "file"
    case location = "location"
    case contact = "contact"
    case system = "system"
}

struct MessageAttachment: Identifiable, Codable {
    let id: Int
    let messageId: Int
    let fileName: String
    let originalName: String
    let fileSize: Int
    let fileType: String
    let filePath: String
    let createdAt: Date
}

struct MessageReaction: Identifiable, Codable {
    let id: Int
    let messageId: Int
    let userId: Int
    let emoji: String
    let emojiName: String
    let createdAt: Date
    
    var user: User?
}
```

#### Models/ChatRoom.swift
```swift
//
//  ChatRoom.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct ChatRoom: Identifiable, Codable {
    let id: Int
    let name: String
    let isGroup: Bool
    let profilePicture: String?
    let createdBy: Int
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var participants: [User] = []
    var lastMessage: Message?
    var unreadCount: Int = 0
    
    var displayName: String {
        if isGroup {
            return name
        } else {
            // 1:1 채팅의 경우, 상대방 이름 표시
            return participants.first?.displayName ?? name
        }
    }
}

struct ChatParticipant: Codable {
    let id: Int
    let chatRoomId: Int
    let userId: Int
    let joinedAt: Date
    let leftAt: Date?
    let isAdmin: Bool
}
```

#### Models/Contact.swift
```swift
//
//  Contact.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct Contact: Identifiable, Codable {
    let id: Int
    let userId: Int
    let contactUserId: Int
    let nickname: String?
    let isFavorite: Bool
    let isPinned: Bool
    let isBlocked: Bool
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var contactUser: User?
}
```

#### Models/BusinessPost.swift
```swift
//
//  BusinessPost.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct BusinessPost: Identifiable, Codable {
    let id: Int
    let userId: Int
    let content: String
    let imageUrl: String?
    let likesCount: Int
    let commentsCount: Int
    let createdAt: Date
    let updatedAt: Date
    
    // 클라이언트 상태
    var isLiked: Bool = false
    var author: User?
}
```

### 3. 서비스 레이어

#### Services/APIService.swift
```swift
//
//  APIService.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

class APIService: ObservableObject {
    static let shared = APIService()
    
    private let baseURL = "https://dovie-hello2sangyun.replit.app"
    private let session = URLSession.shared
    private var cancellables = Set<AnyCancellable>()
    
    private init() {}
    
    func request<T: Codable>(
        endpoint: String,
        method: HTTPMethod = .GET,
        body: Data? = nil,
        headers: [String: String] = [:]
    ) -> AnyPublisher<T, Error> {
        
        guard let url = URL(string: baseURL + endpoint) else {
            return Fail(error: APIError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        request.httpBody = body
        
        // 기본 헤더 설정
        var allHeaders = [
            "Content-Type": "application/json",
            "Accept": "application/json"
        ]
        
        // 전달받은 헤더 추가
        for (key, value) in headers {
            allHeaders[key] = value
        }
        
        // 인증 토큰 추가 (있는 경우)
        if let token = KeychainManager.shared.getToken() {
            allHeaders["Authorization"] = "Bearer \(token)"
        }
        
        // 헤더 설정
        for (key, value) in allHeaders {
            request.setValue(value, forHTTPHeaderField: key)
        }
        
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: T.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    func uploadFile(data: Data, filename: String, endpoint: String) -> AnyPublisher<FileUploadResponse, Error> {
        guard let url = URL(string: baseURL + endpoint) else {
            return Fail(error: APIError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        let boundary = UUID().uuidString
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        
        if let token = KeychainManager.shared.getToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        var body = Data()
        body.append("--\(boundary)\r\n".data(using: .utf8)!)
        body.append("Content-Disposition: form-data; name=\"file\"; filename=\"\(filename)\"\r\n".data(using: .utf8)!)
        body.append("Content-Type: application/octet-stream\r\n\r\n".data(using: .utf8)!)
        body.append(data)
        body.append("\r\n--\(boundary)--\r\n".data(using: .utf8)!)
        
        request.httpBody = body
        
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: FileUploadResponse.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

enum HTTPMethod: String {
    case GET = "GET"
    case POST = "POST"
    case PUT = "PUT"
    case DELETE = "DELETE"
    case PATCH = "PATCH"
}

enum APIError: Error, LocalizedError {
    case invalidURL
    case noData
    case decodingError
    case networkError(String)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "잘못된 URL입니다."
        case .noData:
            return "데이터를 받지 못했습니다."
        case .decodingError:
            return "데이터 파싱 오류입니다."
        case .networkError(let message):
            return "네트워크 오류: \(message)"
        }
    }
}

struct FileUploadResponse: Codable {
    let filename: String
    let originalName: String
    let fileSize: Int
    let fileType: String
    let filePath: String
}
```

#### Services/AuthenticationManager.swift
```swift
//
//  AuthenticationManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import SwiftUI
import Combine

class AuthenticationManager: ObservableObject {
    @Published var currentUser: User?
    @Published var isAuthenticated = false
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        checkAuthenticationStatus()
    }
    
    private func checkAuthenticationStatus() {
        if let token = KeychainManager.shared.getToken() {
            fetchCurrentUser()
        }
    }
    
    private func fetchCurrentUser() {
        APIService.shared.request<User>(
            endpoint: "/api/auth/user",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure = completion {
                    self.logout()
                }
            },
            receiveValue: { user in
                self.currentUser = user
                self.isAuthenticated = true
            }
        )
        .store(in: &cancellables)
    }
    
    func loginWithEmail(email: String, password: String) {
        guard !email.isEmpty && !password.isEmpty else {
            errorMessage = "이메일과 비밀번호를 입력해주세요."
            return
        }
        
        isLoading = true
        errorMessage = nil
        
        let body = [
            "email": email,
            "password": password
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/login",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func signupWithEmail(username: String, displayName: String, email: String, password: String) {
        isLoading = true
        errorMessage = nil
        
        let body = [
            "username": username,
            "displayName": displayName,
            "email": email,
            "password": password
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/register",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func sendPhoneVerification(phoneNumber: String, countryCode: String) {
        isLoading = true
        errorMessage = nil
        
        let fullPhoneNumber = countryCode + phoneNumber
        let body = ["phoneNumber": fullPhoneNumber]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<VerificationResponse>(
            endpoint: "/api/auth/send-phone-verification",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { _ in
                // 인증번호 전송 성공
            }
        )
        .store(in: &cancellables)
    }
    
    func verifyPhoneCode(phoneNumber: String, verificationCode: String) {
        isLoading = true
        errorMessage = nil
        
        let body = [
            "phoneNumber": phoneNumber,
            "verificationCode": verificationCode
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/verify-phone",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func signInWithGoogle() {
        errorMessage = "Google 로그인은 SDK 설정 후 사용 가능합니다."
    }
    
    func signInWithFacebook() {
        errorMessage = "Facebook 로그인은 SDK 설정 후 사용 가능합니다."
    }
    
    func logout() {
        KeychainManager.shared.removeToken()
        currentUser = nil
        isAuthenticated = false
        errorMessage = nil
    }
    
    private func handleLoginSuccess(_ response: LoginResponse) {
        KeychainManager.shared.saveToken(response.token)
        currentUser = response.user
        isAuthenticated = true
        errorMessage = nil
    }
}

// MARK: - Response Models
struct LoginResponse: Codable {
    let token: String
    let user: User
}

struct VerificationResponse: Codable {
    let success: Bool
    let message: String
}
```

#### Services/ChatManager.swift
```swift
//
//  ChatManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

class ChatManager: ObservableObject {
    @Published var chatRooms: [ChatRoom] = []
    @Published var messages: [Message] = []
    @Published var currentChatRoom: ChatRoom?
    @Published var isConnected = false
    @Published var typingUsers: [Int: User] = [:]
    @Published var unreadCounts: [Int: Int] = [:]
    
    private var cancellables = Set<AnyCancellable>()
    private var webSocketService: WebSocketService?
    
    init() {
        setupWebSocket()
    }
    
    private func setupWebSocket() {
        webSocketService = WebSocketService()
        webSocketService?.delegate = self
        webSocketService?.connect()
    }
    
    func loadChatRooms() {
        APIService.shared.request<[ChatRoom]>(
            endpoint: "/api/chat-rooms",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    print("채팅방 로드 실패: \(error)")
                }
            },
            receiveValue: { chatRooms in
                self.chatRooms = chatRooms
                self.loadUnreadCounts()
            }
        )
        .store(in: &cancellables)
    }
    
    func createChatRoom(name: String, participantIds: [Int], isGroup: Bool) {
        let body = [
            "name": name,
            "participantIds": participantIds,
            "isGroup": isGroup
        ] as [String: Any]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<ChatRoom>(
            endpoint: "/api/chat-rooms",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { chatRoom in
                self.chatRooms.insert(chatRoom, at: 0)
            }
        )
        .store(in: &cancellables)
    }
    
    func joinChatRoom(_ chatRoom: ChatRoom) {
        currentChatRoom = chatRoom
        loadMessages(for: chatRoom.id)
        webSocketService?.joinRoom(chatRoom.id)
        markMessagesAsRead(chatRoomId: chatRoom.id)
    }
    
    func leaveChatRoom() {
        if let chatRoom = currentChatRoom {
            webSocketService?.leaveRoom(chatRoom.id)
        }
        currentChatRoom = nil
        messages = []
        typingUsers = [:]
    }
    
    func loadMessages(for chatRoomId: Int) {
        APIService.shared.request<[Message]>(
            endpoint: "/api/chat-rooms/\(chatRoomId)/messages",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    print("메시지 로드 실패: \(error)")
                }
            },
            receiveValue: { messages in
                self.messages = messages
            }
        )
        .store(in: &cancellables)
    }
    
    func sendMessage(content: String) {
        guard let chatRoom = currentChatRoom else { return }
        
        let messageData = [
            "chatRoomId": chatRoom.id,
            "content": content,
            "messageType": "text"
        ] as [String: Any]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: messageData) else {
            return
        }
        
        APIService.shared.request<Message>(
            endpoint: "/api/messages",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { message in
                self.messages.append(message)
            }
        )
        .store(in: &cancellables)
        
        // WebSocket으로도 전송
        webSocketService?.sendMessage(chatRoomId: chatRoom.id, content: content, type: "text")
    }
    
    func sendFileMessage(data: Data, filename: String, type: MessageType) {
        guard let chatRoom = currentChatRoom else { return }
        
        // 먼저 파일 업로드
        APIService.shared.uploadFile(data: data, filename: filename, endpoint: "/api/upload")
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { response in
                    // 파일 업로드 성공 후 메시지 전송
                    let messageData = [
                        "chatRoomId": chatRoom.id,
                        "content": response.filePath,
                        "messageType": type.rawValue,
                        "fileName": response.originalName,
                        "fileSize": response.fileSize
                    ] as [String: Any]
                    
                    guard let bodyData = try? JSONSerialization.data(withJSONObject: messageData) else {
                        return
                    }
                    
                    APIService.shared.request<Message>(
                        endpoint: "/api/messages",
                        method: .POST,
                        body: bodyData,
                        headers: [:]
                    )
                    .sink(
                        receiveCompletion: { _ in },
                        receiveValue: { message in
                            self.messages.append(message)
                        }
                    )
                    .store(in: &self.cancellables)
                }
            )
            .store(in: &cancellables)
    }
    
    func startTyping() {
        guard let chatRoom = currentChatRoom else { return }
        webSocketService?.sendTyping(chatRoomId: chatRoom.id, isTyping: true)
    }
    
    func stopTyping() {
        guard let chatRoom = currentChatRoom else { return }
        webSocketService?.sendTyping(chatRoomId: chatRoom.id, isTyping: false)
    }
    
    private func markMessagesAsRead(chatRoomId: Int) {
        let body = ["chatRoomId": chatRoomId]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<EmptyResponse>(
            endpoint: "/api/messages/mark-read",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { _ in
                self.unreadCounts[chatRoomId] = 0
            }
        )
        .store(in: &cancellables)
    }
    
    private func loadUnreadCounts() {
        APIService.shared.request<[String: Int]>(
            endpoint: "/api/messages/unread-counts",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { counts in
                self.unreadCounts = counts.compactMapValues { $0 }
            }
        )
        .store(in: &cancellables)
    }
}

// MARK: - WebSocket Delegate
extension ChatManager: WebSocketServiceDelegate {
    func webSocketDidConnect() {
        isConnected = true
    }
    
    func webSocketDidDisconnect() {
        isConnected = false
    }
    
    func webSocketDidReceiveMessage(_ message: Message) {
        if message.chatRoomId == currentChatRoom?.id {
            messages.append(message)
        }
        
        // 읽지 않은 메시지 수 업데이트
        if message.chatRoomId != currentChatRoom?.id {
            unreadCounts[message.chatRoomId] = (unreadCounts[message.chatRoomId] ?? 0) + 1
        }
    }
    
    func webSocketDidReceiveTyping(userId: Int, user: User, isTyping: Bool) {
        if isTyping {
            typingUsers[userId] = user
        } else {
            typingUsers.removeValue(forKey: userId)
        }
    }
}

struct EmptyResponse: Codable {}
```

#### Services/WebSocketService.swift
```swift
//
//  WebSocketService.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

protocol WebSocketServiceDelegate: AnyObject {
    func webSocketDidConnect()
    func webSocketDidDisconnect()
    func webSocketDidReceiveMessage(_ message: Message)
    func webSocketDidReceiveTyping(userId: Int, user: User, isTyping: Bool)
}

class WebSocketService: NSObject {
    weak var delegate: WebSocketServiceDelegate?
    
    private var webSocketTask: URLSessionWebSocketTask?
    private let session = URLSession(configuration: .default)
    
    func connect() {
        guard let url = URL(string: "wss://dovie-hello2sangyun.replit.app/ws") else {
            print("Invalid WebSocket URL")
            return
        }
        
        var request = URLRequest(url: url)
        if let token = KeychainManager.shared.getToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        webSocketTask = session.webSocketTask(with: request)
        webSocketTask?.resume()
        
        delegate?.webSocketDidConnect()
        startListening()
    }
    
    func disconnect() {
        webSocketTask?.cancel(with: .normalClosure, reason: nil)
        webSocketTask = nil
        delegate?.webSocketDidDisconnect()
    }
    
    private func startListening() {
        webSocketTask?.receive { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleWebSocketMessage(message)
                self?.startListening() // 계속 수신 대기
            case .failure(let error):
                print("WebSocket 오류: \(error)")
                self?.delegate?.webSocketDidDisconnect()
            }
        }
    }
    
    private func handleWebSocketMessage(_ message: URLSessionWebSocketTask.Message) {
        switch message {
        case .string(let text):
            guard let data = text.data(using: .utf8) else { return }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                let type = json?["type"] as? String
                
                switch type {
                case "message":
                    if let messageData = json?["data"] as? [String: Any],
                       let messageJSON = try? JSONSerialization.data(withJSONObject: messageData),
                       let message = try? JSONDecoder().decode(Message.self, from: messageJSON) {
                        delegate?.webSocketDidReceiveMessage(message)
                    }
                    
                case "typing":
                    if let userId = json?["userId"] as? Int,
                       let isTyping = json?["isTyping"] as? Bool,
                       let userData = json?["user"] as? [String: Any],
                       let userJSON = try? JSONSerialization.data(withJSONObject: userData),
                       let user = try? JSONDecoder().decode(User.self, from: userJSON) {
                        delegate?.webSocketDidReceiveTyping(userId: userId, user: user, isTyping: isTyping)
                    }
                    
                default:
                    break
                }
            } catch {
                print("WebSocket 메시지 파싱 오류: \(error)")
            }
            
        case .data(let data):
            print("Binary 데이터 수신: \(data)")
            
        @unknown default:
            break
        }
    }
    
    func joinRoom(_ roomId: Int) {
        sendWebSocketMessage([
            "type": "join_room",
            "roomId": roomId
        ])
    }
    
    func leaveRoom(_ roomId: Int) {
        sendWebSocketMessage([
            "type": "leave_room",
            "roomId": roomId
        ])
    }
    
    func sendMessage(chatRoomId: Int, content: String, type: String) {
        sendWebSocketMessage([
            "type": "message",
            "chatRoomId": chatRoomId,
            "content": content,
            "messageType": type
        ])
    }
    
    func sendTyping(chatRoomId: Int, isTyping: Bool) {
        sendWebSocketMessage([
            "type": "typing",
            "chatRoomId": chatRoomId,
            "isTyping": isTyping
        ])
    }
    
    private func sendWebSocketMessage(_ message: [String: Any]) {
        guard let data = try? JSONSerialization.data(withJSONObject: message),
              let string = String(data: data, encoding: .utf8) else {
            return
        }
        
        webSocketTask?.send(.string(string)) { error in
            if let error = error {
                print("WebSocket 전송 오류: \(error)")
            }
        }
    }
}
```

#### Services/KeychainManager.swift
```swift
//
//  KeychainManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Security

class KeychainManager {
    static let shared = KeychainManager()
    
    private let tokenKey = "dovie_auth_token"
    private let service = "com.dovie.messenger"
    
    private init() {}
    
    func saveToken(_ token: String) {
        let data = token.data(using: .utf8)!
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey,
            kSecValueData as String: data
        ]
        
        // 기존 토큰 삭제
        SecItemDelete(query as CFDictionary)
        
        // 새 토큰 저장
        let status = SecItemAdd(query as CFDictionary, nil)
        
        if status != errSecSuccess {
            print("키체인 저장 실패: \(status)")
        }
    }
    
    func getToken() -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        if status == errSecSuccess,
           let data = result as? Data,
           let token = String(data: data, encoding: .utf8) {
            return token
        }
        
        return nil
    }
    
    func removeToken() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey
        ]
        
        SecItemDelete(query as CFDictionary)
    }
}
```

#### Services/PushNotificationManager.swift
```swift
//
//  PushNotificationManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import UserNotifications
import UIKit
import Combine

class PushNotificationManager: NSObject, ObservableObject {
    static let shared = PushNotificationManager()
    
    @Published var isAuthorized = false
    @Published var deviceToken: String?
    
    private var cancellables = Set<AnyCancellable>()
    
    override init() {
        super.init()
        checkAuthorizationStatus()
    }
    
    func requestPermissions() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            DispatchQueue.main.async {
                self.isAuthorized = granted
                if granted {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
        }
    }
    
    private func checkAuthorizationStatus() {
        UNUserNotificationCenter.current().getNotificationSettings { settings in
            DispatchQueue.main.async {
                self.isAuthorized = settings.authorizationStatus == .authorized
                if self.isAuthorized {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
        }
    }
    
    func registerDeviceToken(_ deviceToken: Data) {
        let tokenString = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()
        self.deviceToken = tokenString
        
        // 서버에 디바이스 토큰 전송
        sendDeviceTokenToServer(tokenString)
    }
    
    private func sendDeviceTokenToServer(_ token: String) {
        let body = [
            "deviceToken": token,
            "platform": "ios"
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<EmptyResponse>(
            endpoint: "/api/push/register-device",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { _ in }
        )
        .store(in: &cancellables)
    }
    
    func handleNotificationResponse(_ response: UNNotificationResponse) {
        let userInfo = response.notification.request.content.userInfo
        
        // 딥링크 처리
        if let chatRoomId = userInfo["chatRoomId"] as? Int {
            // 특정 채팅방으로 이동
            NotificationCenter.default.post(
                name: NSNotification.Name("OpenChatRoom"),
                object: nil,
                userInfo: ["chatRoomId": chatRoomId]
            )
        }
        
        // 배지 카운트 업데이트
        UIApplication.shared.applicationIconBadgeNumber = 0
    }
}

// MARK: - UNUserNotificationCenterDelegate
extension PushNotificationManager: UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        handleNotificationResponse(response)
        completionHandler()
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.alert, .sound, .badge])
    }
}
```

### 4. UI 뷰 컴포넌트

#### Views/AuthenticationView.swift
```swift
//
//  AuthenticationView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct AuthenticationView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var selectedTab = 0
    
    var body: some View {
        VStack {
            Spacer()
            
            // 로고 및 제목
            VStack(spacing: 16) {
                Text("Dovie")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.purple, .blue],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                
                Text("메신저")
                    .font(.title2)
                    .foregroundColor(.secondary)
            }
            .padding(.bottom, 40)
            
            // 탭 선택
            Picker("로그인 방법", selection: $selectedTab) {
                Text("이메일").tag(0)
                Text("전화번호").tag(1)
                Text("회원가입").tag(2)
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding(.horizontal, 20)
            .padding(.bottom, 30)
            
            // 탭 내용
            TabView(selection: $selectedTab) {
                EmailLoginView()
                    .environmentObject(authManager)
                    .tag(0)
                
                PhoneLoginView()
                    .environmentObject(authManager)
                    .tag(1)
                
                SignupView()
                    .environmentObject(authManager)
                    .tag(2)
            }
            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
            
            Spacer()
            
            // 소셜 로그인
            VStack(spacing: 16) {
                HStack {
                    VStack { Divider() }
                    Text("또는")
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 16)
                    VStack { Divider() }
                }
                
                VStack(spacing: 12) {
                    Button(action: {
                        authManager.signInWithGoogle()
                    }) {
                        HStack {
                            Image(systemName: "globe")
                                .font(.title2)
                                .foregroundColor(.white)
                            
                            Text("Google로 계속하기")
                                .font(.headline)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.red)
                        .cornerRadius(12)
                    }
                    
                    Button(action: {
                        authManager.signInWithFacebook()
                    }) {
                        HStack {
                            Image(systemName: "person.2")
                                .font(.title2)
                                .foregroundColor(.white)
                            
                            Text("Facebook으로 계속하기")
                                .font(.headline)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.blue)
                        .cornerRadius(12)
                    }
                }
            }
            .padding(.horizontal, 20)
            .padding(.bottom, 30)
        }
        .background(Color(.systemBackground))
    }
}

// MARK: - 이메일 로그인 뷰
struct EmailLoginView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var email = ""
    @State private var password = ""
    @State private var showPassword = false
    
    var body: some View {
        VStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 8) {
                Text("이메일")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                TextField("이메일을 입력해주세요", text: $email)
                    .keyboardType(.emailAddress)
                    .autocapitalization(.none)
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
            }
            
            VStack(alignment: .leading, spacing: 8) {
                Text("비밀번호")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                HStack {
                    Group {
                        if showPassword {
                            TextField("비밀번호를 입력해주세요", text: $password)
                        } else {
                            SecureField("비밀번호를 입력해주세요", text: $password)
                        }
                    }
                    
                    Button(action: {
                        showPassword.toggle()
                    }) {
                        Image(systemName: showPassword ? "eye.slash" : "eye")
                            .foregroundColor(.secondary)
                    }
                }
                .padding()
                .background(Color(.systemGray6))
                .cornerRadius(12)
            }
            
            Button(action: {
                authManager.loginWithEmail(email: email, password: password)
            }) {
                HStack {
                    if authManager.isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Text("로그인")
                            .font(.headline)
                    }
                }
                .frame(maxWidth: .infinity)
                .frame(height: 50)
                .background(
                    LinearGradient(
                        colors: [.purple, .blue],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .foregroundColor(.white)
                .cornerRadius(12)
            }
            .disabled(email.isEmpty || password.isEmpty || authManager.isLoading)
            
            if let errorMessage = authManager.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }
        }
        .padding(.horizontal, 20)
    }
}

// MARK: - 전화번호 로그인 뷰
struct PhoneLoginView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var phoneNumber = ""
    @State private var countryCode = "+82"
    @State private var verificationCode = ""
    @State private var showVerificationField = false
    
    var body: some View {
        VStack(spacing: 24) {
            if !showVerificationField {
                VStack(spacing: 16) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("전화번호")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        HStack {
                            Text(countryCode)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 8)
                                .background(Color(.systemGray5))
                                .cornerRadius(8)
                            
                            TextField("전화번호를 입력해주세요", text: $phoneNumber)
                                .keyboardType(.phonePad)
                                .padding()
                                .background(Color(.systemGray6))
                                .cornerRadius(12)
                        }
                    }
                    
                    Button(action: {
                        authManager.sendPhoneVerification(phoneNumber: phoneNumber, countryCode: countryCode)
                        showVerificationField = true
                    }) {
                        HStack {
                            if authManager.isLoading {
                                ProgressView()
                                    .scaleEffect(0.8)
                            } else {
                                Text("인증번호 받기")
                                    .font(.headline)
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(
                            LinearGradient(
                                colors: [.green, .teal],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .disabled(phoneNumber.isEmpty || authManager.isLoading)
                }
            } else {
                VStack(spacing: 16) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("인증번호")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        Text("SMS로 전송된 6자리 인증번호를 입력해주세요")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        TextField("인증번호 입력", text: $verificationCode)
                            .keyboardType(.numberPad)
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(12)
                    }
                    
                    Button(action: {
                        authManager.verifyPhoneCode(phoneNumber: countryCode + phoneNumber, verificationCode: verificationCode)
                    }) {
                        HStack {
                            if authManager.isLoading {
                                ProgressView()
                                    .scaleEffect(0.8)
                            } else {
                                Text("인증 확인")
                                    .font(.headline)
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(
                            LinearGradient(
                                colors: [.green, .teal],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .disabled(verificationCode.count != 6 || authManager.isLoading)
                    
                    Button("다른 번호로 시도하기") {
                        showVerificationField = false
                        phoneNumber = ""
                        verificationCode = ""
                    }
                    .foregroundColor(.secondary)
                }
            }
            
            if let errorMessage = authManager.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }
        }
        .padding(.horizontal, 20)
    }
}

// MARK: - 회원가입 뷰
struct SignupView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var username = ""
    @State private var displayName = ""
    @State private var email = ""
    @State private var password = ""
    @State private var confirmPassword = ""
    @State private var showPassword = false
    @State private var showConfirmPassword = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("사용자명")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("사용자명 입력", text: $username)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .autocapitalization(.none)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("표시 이름")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("표시할 이름 입력", text: $displayName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("이메일")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("이메일 입력", text: $email)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("비밀번호")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        Group {
                            if showPassword {
                                TextField("비밀번호 입력", text: $password)
                            } else {
                                SecureField("비밀번호 입력", text: $password)
                            }
                        }
                        
                        Button(action: {
                            showPassword.toggle()
                        }) {
                            Image(systemName: showPassword ? "eye.slash" : "eye")
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("비밀번호 확인")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        Group {
                            if showConfirmPassword {
                                TextField("비밀번호 다시 입력", text: $confirmPassword)
                            } else {
                                SecureField("비밀번호 다시 입력", text: $confirmPassword)
                            }
                        }
                        
                        Button(action: {
                            showConfirmPassword.toggle()
                        }) {
                            Image(systemName: showConfirmPassword ? "eye.slash" : "eye")
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
                
                Button(action: {
                    authManager.signupWithEmail(
                        username: username,
                        displayName: displayName,
                        email: email,
                        password: password
                    )
                }) {
                    HStack {
                        if authManager.isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Text("회원가입")
                                .font(.headline)
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 50)
                    .background(
                        LinearGradient(
                            colors: [.purple, .blue],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(!isFormValid || authManager.isLoading)
                
                if let errorMessage = authManager.errorMessage {
                    Text(errorMessage)
                        .foregroundColor(.red)
                        .font(.caption)
                        .multilineTextAlignment(.center)
                }
            }
            .padding(.horizontal, 20)
        }
    }
    
    private var isFormValid: Bool {
        !username.isEmpty &&
        !displayName.isEmpty &&
        !email.isEmpty &&
        !password.isEmpty &&
        password == confirmPassword &&
        password.count >= 6
    }
}
```

#### Views/ChatsListView.swift
```swift
//
//  ChatsListView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ChatsListView: View {
    @EnvironmentObject var chatManager: ChatManager
    @State private var searchText = ""
    @State private var showingCreateChat = false
    
    var filteredChatRooms: [ChatRoom] {
        if searchText.isEmpty {
            return chatManager.chatRooms
        } else {
            return chatManager.chatRooms.filter { chatRoom in
                chatRoom.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .foregroundColor(.secondary)
                        
                        TextField("채팅방 검색", text: $searchText)
                            .textFieldStyle(PlainTextFieldStyle())
                    }
                    .padding(8)
                    .background(Color(.systemGray6))
                    .cornerRadius(10)
                    
                    Button("새 채팅") {
                        showingCreateChat = true
                    }
                    .foregroundColor(.purple)
                }
                .padding()
                
                if !chatManager.isConnected {
                    HStack {
                        Image(systemName: "wifi.slash")
                            .foregroundColor(.red)
                        Text("연결 중...")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 8)
                }
                
                List {
                    ForEach(filteredChatRooms) { chatRoom in
                        NavigationLink(destination: ChatRoomView(chatRoom: chatRoom)) {
                            ChatRoomRowView(chatRoom: chatRoom)
                        }
                        .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    }
                }
                .listStyle(PlainListStyle())
                .refreshable {
                    chatManager.loadChatRooms()
                }
            }
            .navigationTitle("채팅")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingCreateChat) {
                CreateChatView()
            }
        }
        .onAppear {
            chatManager.loadChatRooms()
        }
    }
}

struct ChatRoomRowView: View {
    let chatRoom: ChatRoom
    @EnvironmentObject var chatManager: ChatManager
    
    private var unreadCount: Int {
        chatManager.unreadCounts[chatRoom.id] ?? 0
    }
    
    var body: some View {
        HStack(spacing: 12) {
            AsyncImage(url: URL(string: chatRoom.participants.first?.profilePicture ?? "")) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Circle()
                    .fill(LinearGradient(
                        colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
                    .overlay(
                        Text(chatRoom.name.prefix(1))
                            .font(.title2)
                            .foregroundColor(.purple)
                    )
            }
            .frame(width: 50, height: 50)
            .clipShape(Circle())
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(chatRoom.name)
                        .font(.headline)
                        .lineLimit(1)
                    
                    Spacer()
                    
                    Text("방금 전")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Text(chatRoom.lastMessage?.content ?? "새로운 채팅방입니다")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .lineLimit(2)
                    
                    Spacer()
                    
                    if unreadCount > 0 {
                        Text("\(unreadCount)")
                            .font(.caption)
                            .foregroundColor(.white)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.red)
                            .clipShape(Capsule())
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
}

struct CreateChatView: View {
    @Environment(\.presentationMode) var presentationMode
    @EnvironmentObject var chatManager: ChatManager
    @State private var chatName = ""
    @State private var selectedUsers: Set<Int> = []
    @State private var isGroup = false
    
    var body: some View {
        NavigationView {
            VStack {
                Form {
                    Section(header: Text("채팅방 정보")) {
                        TextField("채팅방 이름", text: $chatName)
                        Toggle("그룹 채팅", isOn: $isGroup)
                    }
                }
            }
            .navigationTitle("새 채팅")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("취소") {
                        presentationMode.wrappedValue.dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("생성") {
                        chatManager.createChatRoom(
                            name: chatName,
                            participantIds: Array(selectedUsers),
                            isGroup: isGroup
                        )
                        presentationMode.wrappedValue.dismiss()
                    }
                    .disabled(chatName.isEmpty)
                }
            }
        }
    }
}
```

#### Views/ChatRoomView.swift
```swift
//
//  ChatRoomView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ChatRoomView: View {
    let chatRoom: ChatRoom
    @EnvironmentObject var chatManager: ChatManager
    @State private var messageText = ""
    @State private var showingAttachments = false
    @FocusState private var isTextFieldFocused: Bool
    
    var body: some View {
        VStack(spacing: 0) {
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(spacing: 8) {
                        ForEach(chatManager.messages) { message in
                            MessageBubbleView(message: message)
                                .id(message.id)
                        }
                        
                        if !chatManager.typingUsers.isEmpty {
                            TypingIndicatorView(users: Array(chatManager.typingUsers.values))
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                }
                .onTapGesture {
                    isTextFieldFocused = false
                }
                .onChange(of: chatManager.messages.count) { _ in
                    if let lastMessage = chatManager.messages.last {
                        withAnimation(.easeOut(duration: 0.3)) {
                            proxy.scrollTo(lastMessage.id, anchor: .bottom)
                        }
                    }
                }
            }
            
            Divider()
            
            MessageInputView(
                messageText: $messageText,
                showingAttachments: $showingAttachments,
                isTextFieldFocused: $isTextFieldFocused,
                onSendMessage: sendMessage
            )
        }
        .navigationTitle(chatRoom.name)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            chatManager.joinChatRoom(chatRoom)
        }
        .onDisappear {
            chatManager.leaveChatRoom()
        }
        .onChange(of: messageText) { newValue in
            if !newValue.isEmpty {
                chatManager.startTyping()
            } else {
                chatManager.stopTyping()
            }
        }
    }
    
    private func sendMessage() {
        guard !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        chatManager.sendMessage(content: messageText.trimmingCharacters(in: .whitespacesAndNewlines))
        messageText = ""
        chatManager.stopTyping()
    }
}

struct MessageBubbleView: View {
    let message: Message
    @EnvironmentObject var authManager: AuthenticationManager
    
    private var isFromCurrentUser: Bool {
        message.senderId == authManager.currentUser?.id
    }
    
    var body: some View {
        HStack {
            if isFromCurrentUser {
                Spacer()
            }
            
            VStack(alignment: isFromCurrentUser ? .trailing : .leading, spacing: 4) {
                Text(message.content ?? "")
                    .font(.body)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(isFromCurrentUser ? 
                                LinearGradient(colors: [.purple, .blue], startPoint: .topLeading, endPoint: .bottomTrailing) :
                                Color(.systemGray5)
                            )
                    )
                    .foregroundColor(isFromCurrentUser ? .white : .primary)
                
                Text(formatMessageTime(message.createdAt))
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 4)
            }
            .frame(maxWidth: UIScreen.main.bounds.width * 0.75, alignment: isFromCurrentUser ? .trailing : .leading)
            
            if !isFromCurrentUser {
                Spacer()
            }
        }
    }
    
    private func formatMessageTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }
}

struct MessageInputView: View {
    @Binding var messageText: String
    @Binding var showingAttachments: Bool
    @FocusState.Binding var isTextFieldFocused: Bool
    
    let onSendMessage: () -> Void
    
    var body: some View {
        HStack(alignment: .bottom, spacing: 8) {
            Button(action: {
                showingAttachments = true
            }) {
                Image(systemName: "plus")
                    .font(.title2)
                    .foregroundColor(.purple)
                    .frame(width: 36, height: 36)
                    .background(Circle().fill(Color(.systemGray6)))
            }
            
            HStack(alignment: .bottom, spacing: 8) {
                TextField("메시지 입력...", text: $messageText, axis: .vertical)
                    .textFieldStyle(PlainTextFieldStyle())
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color(.systemGray6))
                    .cornerRadius(20)
                    .focused($isTextFieldFocused)
                    .lineLimit(1...5)
                
                if !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    Button(action: onSendMessage) {
                        Image(systemName: "paperplane.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .frame(width: 36, height: 36)
                            .background(
                                Circle().fill(
                                    LinearGradient(
                                        colors: [.purple, .blue],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                            )
                    }
                }
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .background(Color(.systemBackground))
    }
}

struct TypingIndicatorView: View {
    let users: [User]
    @State private var animationOffset: CGFloat = 0
    
    var body: some View {
        HStack {
            Text("\(users.map(\.displayName).joined(separator: ", "))이 입력 중")
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack(spacing: 4) {
                ForEach(0..<3) { index in
                    Circle()
                        .fill(Color.secondary)
                        .frame(width: 6, height: 6)
                        .offset(y: animationOffset)
                        .animation(
                            Animation.easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                            value: animationOffset
                        )
                }
            }
            
            Spacer()
        }
        .padding(.horizontal)
        .onAppear {
            animationOffset = -4
        }
    }
}
```

### 5. 나머지 뷰들 (요약 버전)

#### Views/ContactsView.swift, SpaceView.swift, ArchiveView.swift, SettingsView.swift



이 뷰들은 연락처 관리, 비즈니스 네트워킹, 파일 아카이브, 설정 기능을 제공하며, 위의 패턴과 동일한 SwiftUI 구조를 따릅니다.

### 6. 유틸리티 및 확장

#### Utils/Constants.swift
```swift
struct Constants {
    static let baseURL = "https://dovie-hello2sangyun.replit.app"
    static let websocketURL = "wss://dovie-hello2sangyun.replit.app/ws"
}
```

#### Extensions/View+Extensions.swift
```swift
import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}
```

### 7. Info.plist 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- 기본 앱 정보 -->
    <key>CFBundleDisplayName</key>
    <string>Dovie Messenger</string>
    
    <!-- 권한 설정 -->
    <key>NSCameraUsageDescription</key>
    <string>사진과 동영상을 촬영하여 메시지로 전송하기 위해 카메라 접근이 필요합니다.</string>
    
    <key>NSPhotoLibraryUsageDescription</key>
    <string>사진과 동영상을 선택하여 메시지로 전송하기 위해 사진 라이브러리 접근이 필요합니다.</string>
    
    <key>NSMicrophoneUsageDescription</key>
    <string>음성 메시지를 녹음하기 위해 마이크 접근이 필요합니다.</string>
    
    <key>NSContactsUsageDescription</key>
    <string>친구를 찾고 연락처를 동기화하기 위해 연락처 접근이 필요합니다.</string>
    
    <!-- 백그라운드 모드 -->
    <key>UIBackgroundModes</key>
    <array>
        <string>background-processing</string>
        <string>remote-notification</string>
        <string>background-fetch</string>
    </array>
    
    <!-- URL 스키마 -->
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLName</key>
            <string>com.dovie.messenger</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>dovie</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
```

## 📋 Xcode 프로젝트 설정 가이드

### 1. 새 프로젝트 생성
- Xcode에서 "Create a new Xcode project"
- iOS > App 선택
- Product Name: "DovieMessenger"
- Interface: SwiftUI
- Language: Swift

### 2. 파일 구조 생성
각 폴더를 만들고 위의 Swift 파일들을 순서대로 추가합니다.

### 3. Swift Package Dependencies 추가
프로젝트 설정에서 다음 패키지들을 추가하세요:
- Google Sign-In SDK (Google 로그인용)
- Facebook SDK (Facebook 로그인용)

### 4. 실행 및 테스트
- iOS 시뮬레이터에서 앱 실행
- Replit 서버와의 API 연동 테스트
- WebSocket 실시간 통신 확인

이 코드는 완전한 네이티브 iOS 메신저 앱을 구현하며, Replit 백엔드 서버와 완벽하게 연동됩니다.