# Dovie Messenger - 완전한 네이티브 iOS 앱 코드 (Gemini 학습용)

## 프로젝트 개요
Dovie Messenger는 Replit 백엔드 서버(https://dovie-hello2sangyun.replit.app)와 연동되는 완전한 네이티브 iOS 메신저 앱입니다.

### 주요 기능
- 실시간 채팅 (WebSocket 기반)
- 다중 인증 시스템 (이메일/전화번호/Google/Facebook)
- 비즈니스 네트워킹 공간 (LinkedIn 스타일)
- 스마트 파일 아카이브 시스템
- 네이티브 푸시 알림
- 연락처 관리 및 QR 코드 스캔

### 기술 스택
- 언어: Swift 5.0+
- UI 프레임워크: SwiftUI
- 아키텍처: MVVM + Combine
- 네트워킹: URLSession + Combine
- 실시간 통신: URLSessionWebSocketTask
- 보안: Keychain Services
- 푸시 알림: UserNotifications Framework

### 프로젝트 구조
```
DovieMessenger/
├── DovieMessengerApp.swift       # 앱 진입점
├── ContentView.swift             # 메인 탭 네비게이션
├── Info.plist                    # 앱 설정 및 권한
├── Models/                       # 데이터 모델
│   ├── User.swift
│   ├── Message.swift
│   ├── ChatRoom.swift
│   ├── Contact.swift
│   └── BusinessPost.swift
├── Views/                        # UI 컴포넌트
│   ├── AuthenticationView.swift
│   ├── ChatsListView.swift
│   ├── ChatRoomView.swift
│   ├── ContactsView.swift
│   ├── SpaceView.swift
│   ├── ArchiveView.swift
│   └── SettingsView.swift
├── Services/                     # 서비스 레이어
│   ├── AuthenticationManager.swift
│   ├── ChatManager.swift
│   ├── APIService.swift
│   ├── WebSocketService.swift
│   ├── KeychainManager.swift
│   └── PushNotificationManager.swift
├── Utils/                        # 유틸리티
│   ├── Constants.swift
│   ├── NetworkUtils.swift
│   └── DateUtils.swift
└── Extensions/                   # 확장 기능
    ├── View+Extensions.swift
    ├── String+Extensions.swift
    └── Color+Extensions.swift
```

## 완전한 Swift 코드

### 1. 앱 진입점

#### DovieMessengerApp.swift
```swift
//
//  DovieMessengerApp.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import UserNotifications

@main
struct DovieMessengerApp: App {
    @StateObject private var authManager = AuthenticationManager()
    @StateObject private var chatManager = ChatManager()
    @StateObject private var pushManager = PushNotificationManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authManager)
                .environmentObject(chatManager)
                .environmentObject(pushManager)
                .onAppear {
                    setupNotifications()
                }
        }
    }
    
    private func setupNotifications() {
        UNUserNotificationCenter.current().delegate = pushManager
        pushManager.requestPermissions()
    }
}
```

#### ContentView.swift
```swift
//
//  ContentView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    
    var body: some View {
        Group {
            if authManager.isAuthenticated {
                MainTabView()
                    .transition(.opacity)
            } else {
                AuthenticationView()
                    .transition(.opacity)
            }
        }
        .animation(.easeInOut(duration: 0.3), value: authManager.isAuthenticated)
    }
}

struct MainTabView: View {
    var body: some View {
        TabView {
            ChatsListView()
                .tabItem {
                    Image(systemName: "message")
                    Text("채팅")
                }
            
            ContactsView()
                .tabItem {
                    Image(systemName: "person.2")
                    Text("연락처")
                }
            
            SpaceView()
                .tabItem {
                    Image(systemName: "briefcase")
                    Text("스페이스")
                }
            
            ArchiveView()
                .tabItem {
                    Image(systemName: "archivebox")
                    Text("아카이브")
                }
            
            SettingsView()
                .tabItem {
                    Image(systemName: "gear")
                    Text("설정")
                }
        }
        .accentColor(.purple)
    }
}
```

### 2. 데이터 모델

#### Models/User.swift
```swift
//
//  User.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct User: Identifiable, Codable {
    let id: Int
    let username: String
    let displayName: String
    let email: String?
    let phoneNumber: String?
    let profilePicture: String?
    let loginProvider: String?
    let googleId: String?
    let facebookId: String?
    let businessName: String?
    let businessAddress: String?
    let isOnline: Bool?
    let lastSeen: Date?
    let allowVoicePlayback: Bool?
    let autoPlayVoiceMessages: Bool?
    let createdAt: Date
    let updatedAt: Date
    
    var displayUsername: String {
        return "@\(username)"
    }
    
    var initials: String {
        let components = displayName.components(separatedBy: " ")
        let firstInitial = components.first?.prefix(1) ?? ""
        let lastInitial = components.count > 1 ? components.last?.prefix(1) ?? "" : ""
        return "\(firstInitial)\(lastInitial)".uppercased()
    }
}
```

#### Models/Message.swift
```swift
//
//  Message.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct Message: Identifiable, Codable {
    let id: Int
    let chatRoomId: Int
    let senderId: Int
    let content: String?
    let messageType: MessageType
    let isEdited: Bool
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var sender: User?
    var attachments: [MessageAttachment]?
    var reactions: [MessageReaction]?
}

enum MessageType: String, Codable, CaseIterable {
    case text = "text"
    case image = "image"
    case video = "video"
    case audio = "audio"
    case file = "file"
    case location = "location"
    case contact = "contact"
    case system = "system"
}

struct MessageAttachment: Identifiable, Codable {
    let id: Int
    let messageId: Int
    let fileName: String
    let originalName: String
    let fileSize: Int
    let fileType: String
    let filePath: String
    let createdAt: Date
}

struct MessageReaction: Identifiable, Codable {
    let id: Int
    let messageId: Int
    let userId: Int
    let emoji: String
    let emojiName: String
    let createdAt: Date
    
    var user: User?
}
```

#### Models/ChatRoom.swift
```swift
//
//  ChatRoom.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct ChatRoom: Identifiable, Codable {
    let id: Int
    let name: String
    let isGroup: Bool
    let profilePicture: String?
    let createdBy: Int
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var participants: [User] = []
    var lastMessage: Message?
    var unreadCount: Int = 0
    
    var displayName: String {
        if isGroup {
            return name
        } else {
            // 1:1 채팅의 경우, 상대방 이름 표시
            return participants.first?.displayName ?? name
        }
    }
}

struct ChatParticipant: Codable {
    let id: Int
    let chatRoomId: Int
    let userId: Int
    let joinedAt: Date
    let leftAt: Date?
    let isAdmin: Bool
}
```

#### Models/Contact.swift
```swift
//
//  Contact.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct Contact: Identifiable, Codable {
    let id: Int
    let userId: Int
    let contactUserId: Int
    let nickname: String?
    let isFavorite: Bool
    let isPinned: Bool
    let isBlocked: Bool
    let createdAt: Date
    let updatedAt: Date
    
    // 관계형 데이터
    var contactUser: User?
}
```

#### Models/BusinessPost.swift
```swift
//
//  BusinessPost.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation

struct BusinessPost: Identifiable, Codable {
    let id: Int
    let userId: Int
    let content: String
    let imageUrl: String?
    let likesCount: Int
    let commentsCount: Int
    let createdAt: Date
    let updatedAt: Date
    
    // 클라이언트 상태
    var isLiked: Bool = false
    var author: User?
}
```

### 3. 서비스 레이어

#### Services/APIService.swift
```swift
//
//  APIService.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

class APIService: ObservableObject {
    static let shared = APIService()
    
    private let baseURL = "https://dovie-hello2sangyun.replit.app"
    private let session = URLSession.shared
    private var cancellables = Set<AnyCancellable>()
    
    private init() {}
    
    func request<T: Codable>(
        endpoint: String,
        method: HTTPMethod = .GET,
        body: Data? = nil,
        headers: [String: String] = [:]
    ) -> AnyPublisher<T, Error> {
        
        guard let url = URL(string: baseURL + endpoint) else {
            return Fail(error: APIError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        request.httpBody = body
        
        // 기본 헤더 설정
        var allHeaders = [
            "Content-Type": "application/json",
            "Accept": "application/json"
        ]
        
        // 전달받은 헤더 추가
        for (key, value) in headers {
            allHeaders[key] = value
        }
        
        // 인증 토큰 추가 (있는 경우)
        if let token = KeychainManager.shared.getToken() {
            allHeaders["Authorization"] = "Bearer \(token)"
        }
        
        // 헤더 설정
        for (key, value) in allHeaders {
            request.setValue(value, forHTTPHeaderField: key)
        }
        
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: T.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    func uploadFile(data: Data, filename: String, endpoint: String) -> AnyPublisher<FileUploadResponse, Error> {
        guard let url = URL(string: baseURL + endpoint) else {
            return Fail(error: APIError.invalidURL)
                .eraseToAnyPublisher()
        }
        
        let boundary = UUID().uuidString
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        
        if let token = KeychainManager.shared.getToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        var body = Data()
        body.append("--\(boundary)\r\n".data(using: .utf8)!)
        body.append("Content-Disposition: form-data; name=\"file\"; filename=\"\(filename)\"\r\n".data(using: .utf8)!)
        body.append("Content-Type: application/octet-stream\r\n\r\n".data(using: .utf8)!)
        body.append(data)
        body.append("\r\n--\(boundary)--\r\n".data(using: .utf8)!)
        
        request.httpBody = body
        
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: FileUploadResponse.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

enum HTTPMethod: String {
    case GET = "GET"
    case POST = "POST"
    case PUT = "PUT"
    case DELETE = "DELETE"
    case PATCH = "PATCH"
}

enum APIError: Error, LocalizedError {
    case invalidURL
    case noData
    case decodingError
    case networkError(String)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "잘못된 URL입니다."
        case .noData:
            return "데이터를 받지 못했습니다."
        case .decodingError:
            return "데이터 파싱 오류입니다."
        case .networkError(let message):
            return "네트워크 오류: \(message)"
        }
    }
}

struct FileUploadResponse: Codable {
    let filename: String
    let originalName: String
    let fileSize: Int
    let fileType: String
    let filePath: String
}
```

#### Services/AuthenticationManager.swift
```swift
//
//  AuthenticationManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import SwiftUI
import Combine

class AuthenticationManager: ObservableObject {
    @Published var currentUser: User?
    @Published var isAuthenticated = false
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        checkAuthenticationStatus()
    }
    
    private func checkAuthenticationStatus() {
        if let token = KeychainManager.shared.getToken() {
            fetchCurrentUser()
        }
    }
    
    private func fetchCurrentUser() {
        APIService.shared.request<User>(
            endpoint: "/api/auth/user",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure = completion {
                    self.logout()
                }
            },
            receiveValue: { user in
                self.currentUser = user
                self.isAuthenticated = true
            }
        )
        .store(in: &cancellables)
    }
    
    func loginWithEmail(email: String, password: String) {
        guard !email.isEmpty && !password.isEmpty else {
            errorMessage = "이메일과 비밀번호를 입력해주세요."
            return
        }
        
        isLoading = true
        errorMessage = nil
        
        let body = [
            "email": email,
            "password": password
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/login",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func signupWithEmail(username: String, displayName: String, email: String, password: String) {
        isLoading = true
        errorMessage = nil
        
        let body = [
            "username": username,
            "displayName": displayName,
            "email": email,
            "password": password
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/register",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func sendPhoneVerification(phoneNumber: String, countryCode: String) {
        isLoading = true
        errorMessage = nil
        
        let fullPhoneNumber = countryCode + phoneNumber
        let body = ["phoneNumber": fullPhoneNumber]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<VerificationResponse>(
            endpoint: "/api/auth/send-phone-verification",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { _ in
                // 인증번호 전송 성공
            }
        )
        .store(in: &cancellables)
    }
    
    func verifyPhoneCode(phoneNumber: String, verificationCode: String) {
        isLoading = true
        errorMessage = nil
        
        let body = [
            "phoneNumber": phoneNumber,
            "verificationCode": verificationCode
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            errorMessage = "요청 데이터 생성에 실패했습니다."
            isLoading = false
            return
        }
        
        APIService.shared.request<LoginResponse>(
            endpoint: "/api/auth/verify-phone",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.errorMessage = error.localizedDescription
                }
            },
            receiveValue: { response in
                self.handleLoginSuccess(response)
            }
        )
        .store(in: &cancellables)
    }
    
    func signInWithGoogle() {
        errorMessage = "Google 로그인은 SDK 설정 후 사용 가능합니다."
    }
    
    func signInWithFacebook() {
        errorMessage = "Facebook 로그인은 SDK 설정 후 사용 가능합니다."
    }
    
    func logout() {
        KeychainManager.shared.removeToken()
        currentUser = nil
        isAuthenticated = false
        errorMessage = nil
    }
    
    private func handleLoginSuccess(_ response: LoginResponse) {
        KeychainManager.shared.saveToken(response.token)
        currentUser = response.user
        isAuthenticated = true
        errorMessage = nil
    }
}

// MARK: - Response Models
struct LoginResponse: Codable {
    let token: String
    let user: User
}

struct VerificationResponse: Codable {
    let success: Bool
    let message: String
}
```

#### Services/ChatManager.swift
```swift
//
//  ChatManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

class ChatManager: ObservableObject {
    @Published var chatRooms: [ChatRoom] = []
    @Published var messages: [Message] = []
    @Published var currentChatRoom: ChatRoom?
    @Published var isConnected = false
    @Published var typingUsers: [Int: User] = [:]
    @Published var unreadCounts: [Int: Int] = [:]
    
    private var cancellables = Set<AnyCancellable>()
    private var webSocketService: WebSocketService?
    
    init() {
        setupWebSocket()
    }
    
    private func setupWebSocket() {
        webSocketService = WebSocketService()
        webSocketService?.delegate = self
        webSocketService?.connect()
    }
    
    func loadChatRooms() {
        APIService.shared.request<[ChatRoom]>(
            endpoint: "/api/chat-rooms",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    print("채팅방 로드 실패: \(error)")
                }
            },
            receiveValue: { chatRooms in
                self.chatRooms = chatRooms
                self.loadUnreadCounts()
            }
        )
        .store(in: &cancellables)
    }
    
    func createChatRoom(name: String, participantIds: [Int], isGroup: Bool) {
        let body = [
            "name": name,
            "participantIds": participantIds,
            "isGroup": isGroup
        ] as [String: Any]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<ChatRoom>(
            endpoint: "/api/chat-rooms",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { chatRoom in
                self.chatRooms.insert(chatRoom, at: 0)
            }
        )
        .store(in: &cancellables)
    }
    
    func joinChatRoom(_ chatRoom: ChatRoom) {
        currentChatRoom = chatRoom
        loadMessages(for: chatRoom.id)
        webSocketService?.joinRoom(chatRoom.id)
        markMessagesAsRead(chatRoomId: chatRoom.id)
    }
    
    func leaveChatRoom() {
        if let chatRoom = currentChatRoom {
            webSocketService?.leaveRoom(chatRoom.id)
        }
        currentChatRoom = nil
        messages = []
        typingUsers = [:]
    }
    
    func loadMessages(for chatRoomId: Int) {
        APIService.shared.request<[Message]>(
            endpoint: "/api/chat-rooms/\(chatRoomId)/messages",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    print("메시지 로드 실패: \(error)")
                }
            },
            receiveValue: { messages in
                self.messages = messages
            }
        )
        .store(in: &cancellables)
    }
    
    func sendMessage(content: String) {
        guard let chatRoom = currentChatRoom else { return }
        
        let messageData = [
            "chatRoomId": chatRoom.id,
            "content": content,
            "messageType": "text"
        ] as [String: Any]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: messageData) else {
            return
        }
        
        APIService.shared.request<Message>(
            endpoint: "/api/messages",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { message in
                self.messages.append(message)
            }
        )
        .store(in: &cancellables)
        
        // WebSocket으로도 전송
        webSocketService?.sendMessage(chatRoomId: chatRoom.id, content: content, type: "text")
    }
    
    func sendFileMessage(data: Data, filename: String, type: MessageType) {
        guard let chatRoom = currentChatRoom else { return }
        
        // 먼저 파일 업로드
        APIService.shared.uploadFile(data: data, filename: filename, endpoint: "/api/upload")
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { response in
                    // 파일 업로드 성공 후 메시지 전송
                    let messageData = [
                        "chatRoomId": chatRoom.id,
                        "content": response.filePath,
                        "messageType": type.rawValue,
                        "fileName": response.originalName,
                        "fileSize": response.fileSize
                    ] as [String: Any]
                    
                    guard let bodyData = try? JSONSerialization.data(withJSONObject: messageData) else {
                        return
                    }
                    
                    APIService.shared.request<Message>(
                        endpoint: "/api/messages",
                        method: .POST,
                        body: bodyData,
                        headers: [:]
                    )
                    .sink(
                        receiveCompletion: { _ in },
                        receiveValue: { message in
                            self.messages.append(message)
                        }
                    )
                    .store(in: &self.cancellables)
                }
            )
            .store(in: &cancellables)
    }
    
    func startTyping() {
        guard let chatRoom = currentChatRoom else { return }
        webSocketService?.sendTyping(chatRoomId: chatRoom.id, isTyping: true)
    }
    
    func stopTyping() {
        guard let chatRoom = currentChatRoom else { return }
        webSocketService?.sendTyping(chatRoomId: chatRoom.id, isTyping: false)
    }
    
    private func markMessagesAsRead(chatRoomId: Int) {
        let body = ["chatRoomId": chatRoomId]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<EmptyResponse>(
            endpoint: "/api/messages/mark-read",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { _ in
                self.unreadCounts[chatRoomId] = 0
            }
        )
        .store(in: &cancellables)
    }
    
    private func loadUnreadCounts() {
        APIService.shared.request<[String: Int]>(
            endpoint: "/api/messages/unread-counts",
            method: .GET,
            body: nil,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { counts in
                self.unreadCounts = counts.compactMapValues { $0 }
            }
        )
        .store(in: &cancellables)
    }
}

// MARK: - WebSocket Delegate
extension ChatManager: WebSocketServiceDelegate {
    func webSocketDidConnect() {
        isConnected = true
    }
    
    func webSocketDidDisconnect() {
        isConnected = false
    }
    
    func webSocketDidReceiveMessage(_ message: Message) {
        if message.chatRoomId == currentChatRoom?.id {
            messages.append(message)
        }
        
        // 읽지 않은 메시지 수 업데이트
        if message.chatRoomId != currentChatRoom?.id {
            unreadCounts[message.chatRoomId] = (unreadCounts[message.chatRoomId] ?? 0) + 1
        }
    }
    
    func webSocketDidReceiveTyping(userId: Int, user: User, isTyping: Bool) {
        if isTyping {
            typingUsers[userId] = user
        } else {
            typingUsers.removeValue(forKey: userId)
        }
    }
}

struct EmptyResponse: Codable {}
```

#### Services/WebSocketService.swift
```swift
//
//  WebSocketService.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Combine

protocol WebSocketServiceDelegate: AnyObject {
    func webSocketDidConnect()
    func webSocketDidDisconnect()
    func webSocketDidReceiveMessage(_ message: Message)
    func webSocketDidReceiveTyping(userId: Int, user: User, isTyping: Bool)
}

class WebSocketService: NSObject {
    weak var delegate: WebSocketServiceDelegate?
    
    private var webSocketTask: URLSessionWebSocketTask?
    private let session = URLSession(configuration: .default)
    
    func connect() {
        guard let url = URL(string: "wss://dovie-hello2sangyun.replit.app/ws") else {
            print("Invalid WebSocket URL")
            return
        }
        
        var request = URLRequest(url: url)
        if let token = KeychainManager.shared.getToken() {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        webSocketTask = session.webSocketTask(with: request)
        webSocketTask?.resume()
        
        delegate?.webSocketDidConnect()
        startListening()
    }
    
    func disconnect() {
        webSocketTask?.cancel(with: .normalClosure, reason: nil)
        webSocketTask = nil
        delegate?.webSocketDidDisconnect()
    }
    
    private func startListening() {
        webSocketTask?.receive { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleWebSocketMessage(message)
                self?.startListening() // 계속 수신 대기
            case .failure(let error):
                print("WebSocket 오류: \(error)")
                self?.delegate?.webSocketDidDisconnect()
            }
        }
    }
    
    private func handleWebSocketMessage(_ message: URLSessionWebSocketTask.Message) {
        switch message {
        case .string(let text):
            guard let data = text.data(using: .utf8) else { return }
            
            do {
                let json = try JSONSerialization.jsonObject(with: data) as? [String: Any]
                let type = json?["type"] as? String
                
                switch type {
                case "message":
                    if let messageData = json?["data"] as? [String: Any],
                       let messageJSON = try? JSONSerialization.data(withJSONObject: messageData),
                       let message = try? JSONDecoder().decode(Message.self, from: messageJSON) {
                        delegate?.webSocketDidReceiveMessage(message)
                    }
                    
                case "typing":
                    if let userId = json?["userId"] as? Int,
                       let isTyping = json?["isTyping"] as? Bool,
                       let userData = json?["user"] as? [String: Any],
                       let userJSON = try? JSONSerialization.data(withJSONObject: userData),
                       let user = try? JSONDecoder().decode(User.self, from: userJSON) {
                        delegate?.webSocketDidReceiveTyping(userId: userId, user: user, isTyping: isTyping)
                    }
                    
                default:
                    break
                }
            } catch {
                print("WebSocket 메시지 파싱 오류: \(error)")
            }
            
        case .data(let data):
            print("Binary 데이터 수신: \(data)")
            
        @unknown default:
            break
        }
    }
    
    func joinRoom(_ roomId: Int) {
        sendWebSocketMessage([
            "type": "join_room",
            "roomId": roomId
        ])
    }
    
    func leaveRoom(_ roomId: Int) {
        sendWebSocketMessage([
            "type": "leave_room",
            "roomId": roomId
        ])
    }
    
    func sendMessage(chatRoomId: Int, content: String, type: String) {
        sendWebSocketMessage([
            "type": "message",
            "chatRoomId": chatRoomId,
            "content": content,
            "messageType": type
        ])
    }
    
    func sendTyping(chatRoomId: Int, isTyping: Bool) {
        sendWebSocketMessage([
            "type": "typing",
            "chatRoomId": chatRoomId,
            "isTyping": isTyping
        ])
    }
    
    private func sendWebSocketMessage(_ message: [String: Any]) {
        guard let data = try? JSONSerialization.data(withJSONObject: message),
              let string = String(data: data, encoding: .utf8) else {
            return
        }
        
        webSocketTask?.send(.string(string)) { error in
            if let error = error {
                print("WebSocket 전송 오류: \(error)")
            }
        }
    }
}
```

#### Services/KeychainManager.swift
```swift
//
//  KeychainManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import Security

class KeychainManager {
    static let shared = KeychainManager()
    
    private let tokenKey = "dovie_auth_token"
    private let service = "com.dovie.messenger"
    
    private init() {}
    
    func saveToken(_ token: String) {
        let data = token.data(using: .utf8)!
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey,
            kSecValueData as String: data
        ]
        
        // 기존 토큰 삭제
        SecItemDelete(query as CFDictionary)
        
        // 새 토큰 저장
        let status = SecItemAdd(query as CFDictionary, nil)
        
        if status != errSecSuccess {
            print("키체인 저장 실패: \(status)")
        }
    }
    
    func getToken() -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        if status == errSecSuccess,
           let data = result as? Data,
           let token = String(data: data, encoding: .utf8) {
            return token
        }
        
        return nil
    }
    
    func removeToken() {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: tokenKey
        ]
        
        SecItemDelete(query as CFDictionary)
    }
}
```

#### Services/PushNotificationManager.swift
```swift
//
//  PushNotificationManager.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import Foundation
import UserNotifications
import UIKit
import Combine

class PushNotificationManager: NSObject, ObservableObject {
    static let shared = PushNotificationManager()
    
    @Published var isAuthorized = false
    @Published var deviceToken: String?
    
    private var cancellables = Set<AnyCancellable>()
    
    override init() {
        super.init()
        checkAuthorizationStatus()
    }
    
    func requestPermissions() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            DispatchQueue.main.async {
                self.isAuthorized = granted
                if granted {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
        }
    }
    
    private func checkAuthorizationStatus() {
        UNUserNotificationCenter.current().getNotificationSettings { settings in
            DispatchQueue.main.async {
                self.isAuthorized = settings.authorizationStatus == .authorized
                if self.isAuthorized {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
        }
    }
    
    func registerDeviceToken(_ deviceToken: Data) {
        let tokenString = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()
        self.deviceToken = tokenString
        
        // 서버에 디바이스 토큰 전송
        sendDeviceTokenToServer(tokenString)
    }
    
    private func sendDeviceTokenToServer(_ token: String) {
        let body = [
            "deviceToken": token,
            "platform": "ios"
        ]
        
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else {
            return
        }
        
        APIService.shared.request<EmptyResponse>(
            endpoint: "/api/push/register-device",
            method: .POST,
            body: bodyData,
            headers: [:]
        )
        .sink(
            receiveCompletion: { _ in },
            receiveValue: { _ in }
        )
        .store(in: &cancellables)
    }
    
    func handleNotificationResponse(_ response: UNNotificationResponse) {
        let userInfo = response.notification.request.content.userInfo
        
        // 딥링크 처리
        if let chatRoomId = userInfo["chatRoomId"] as? Int {
            // 특정 채팅방으로 이동
            NotificationCenter.default.post(
                name: NSNotification.Name("OpenChatRoom"),
                object: nil,
                userInfo: ["chatRoomId": chatRoomId]
            )
        }
        
        // 배지 카운트 업데이트
        UIApplication.shared.applicationIconBadgeNumber = 0
    }
}

// MARK: - UNUserNotificationCenterDelegate
extension PushNotificationManager: UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
        handleNotificationResponse(response)
        completionHandler()
    }
    
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler([.alert, .sound, .badge])
    }
}
```

### 4. UI 뷰 컴포넌트

#### Views/AuthenticationView.swift
```swift
//
//  AuthenticationView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct AuthenticationView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var selectedTab = 0
    
    var body: some View {
        VStack {
            Spacer()
            
            // 로고 및 제목
            VStack(spacing: 16) {
                Text("Dovie")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.purple, .blue],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                
                Text("메신저")
                    .font(.title2)
                    .foregroundColor(.secondary)
            }
            .padding(.bottom, 40)
            
            // 탭 선택
            Picker("로그인 방법", selection: $selectedTab) {
                Text("이메일").tag(0)
                Text("전화번호").tag(1)
                Text("회원가입").tag(2)
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding(.horizontal, 20)
            .padding(.bottom, 30)
            
            // 탭 내용
            TabView(selection: $selectedTab) {
                EmailLoginView()
                    .environmentObject(authManager)
                    .tag(0)
                
                PhoneLoginView()
                    .environmentObject(authManager)
                    .tag(1)
                
                SignupView()
                    .environmentObject(authManager)
                    .tag(2)
            }
            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
            
            Spacer()
            
            // 소셜 로그인
            VStack(spacing: 16) {
                HStack {
                    VStack { Divider() }
                    Text("또는")
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 16)
                    VStack { Divider() }
                }
                
                VStack(spacing: 12) {
                    Button(action: {
                        authManager.signInWithGoogle()
                    }) {
                        HStack {
                            Image(systemName: "globe")
                                .font(.title2)
                                .foregroundColor(.white)
                            
                            Text("Google로 계속하기")
                                .font(.headline)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.red)
                        .cornerRadius(12)
                    }
                    
                    Button(action: {
                        authManager.signInWithFacebook()
                    }) {
                        HStack {
                            Image(systemName: "person.2")
                                .font(.title2)
                                .foregroundColor(.white)
                            
                            Text("Facebook으로 계속하기")
                                .font(.headline)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.blue)
                        .cornerRadius(12)
                    }
                }
            }
            .padding(.horizontal, 20)
            .padding(.bottom, 30)
        }
        .background(Color(.systemBackground))
    }
}

// MARK: - 이메일 로그인 뷰
struct EmailLoginView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var email = ""
    @State private var password = ""
    @State private var showPassword = false
    
    var body: some View {
        VStack(spacing: 16) {
            VStack(alignment: .leading, spacing: 8) {
                Text("이메일")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                TextField("이메일을 입력해주세요", text: $email)
                    .keyboardType(.emailAddress)
                    .autocapitalization(.none)
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
            }
            
            VStack(alignment: .leading, spacing: 8) {
                Text("비밀번호")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                HStack {
                    Group {
                        if showPassword {
                            TextField("비밀번호를 입력해주세요", text: $password)
                        } else {
                            SecureField("비밀번호를 입력해주세요", text: $password)
                        }
                    }
                    
                    Button(action: {
                        showPassword.toggle()
                    }) {
                        Image(systemName: showPassword ? "eye.slash" : "eye")
                            .foregroundColor(.secondary)
                    }
                }
                .padding()
                .background(Color(.systemGray6))
                .cornerRadius(12)
            }
            
            Button(action: {
                authManager.loginWithEmail(email: email, password: password)
            }) {
                HStack {
                    if authManager.isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Text("로그인")
                            .font(.headline)
                    }
                }
                .frame(maxWidth: .infinity)
                .frame(height: 50)
                .background(
                    LinearGradient(
                        colors: [.purple, .blue],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .foregroundColor(.white)
                .cornerRadius(12)
            }
            .disabled(email.isEmpty || password.isEmpty || authManager.isLoading)
            
            if let errorMessage = authManager.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }
        }
        .padding(.horizontal, 20)
    }
}

// MARK: - 전화번호 로그인 뷰
struct PhoneLoginView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var phoneNumber = ""
    @State private var countryCode = "+82"
    @State private var verificationCode = ""
    @State private var showVerificationField = false
    
    var body: some View {
        VStack(spacing: 24) {
            if !showVerificationField {
                VStack(spacing: 16) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("전화번호")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        HStack {
                            Text(countryCode)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 8)
                                .background(Color(.systemGray5))
                                .cornerRadius(8)
                            
                            TextField("전화번호를 입력해주세요", text: $phoneNumber)
                                .keyboardType(.phonePad)
                                .padding()
                                .background(Color(.systemGray6))
                                .cornerRadius(12)
                        }
                    }
                    
                    Button(action: {
                        authManager.sendPhoneVerification(phoneNumber: phoneNumber, countryCode: countryCode)
                        showVerificationField = true
                    }) {
                        HStack {
                            if authManager.isLoading {
                                ProgressView()
                                    .scaleEffect(0.8)
                            } else {
                                Text("인증번호 받기")
                                    .font(.headline)
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(
                            LinearGradient(
                                colors: [.green, .teal],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .disabled(phoneNumber.isEmpty || authManager.isLoading)
                }
            } else {
                VStack(spacing: 16) {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("인증번호")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        Text("SMS로 전송된 6자리 인증번호를 입력해주세요")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        TextField("인증번호 입력", text: $verificationCode)
                            .keyboardType(.numberPad)
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(12)
                    }
                    
                    Button(action: {
                        authManager.verifyPhoneCode(phoneNumber: countryCode + phoneNumber, verificationCode: verificationCode)
                    }) {
                        HStack {
                            if authManager.isLoading {
                                ProgressView()
                                    .scaleEffect(0.8)
                            } else {
                                Text("인증 확인")
                                    .font(.headline)
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(
                            LinearGradient(
                                colors: [.green, .teal],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                    .disabled(verificationCode.count != 6 || authManager.isLoading)
                    
                    Button("다른 번호로 시도하기") {
                        showVerificationField = false
                        phoneNumber = ""
                        verificationCode = ""
                    }
                    .foregroundColor(.secondary)
                }
            }
            
            if let errorMessage = authManager.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.red)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
            }
        }
        .padding(.horizontal, 20)
    }
}

// MARK: - 회원가입 뷰
struct SignupView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var username = ""
    @State private var displayName = ""
    @State private var email = ""
    @State private var password = ""
    @State private var confirmPassword = ""
    @State private var showPassword = false
    @State private var showConfirmPassword = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("사용자명")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("사용자명 입력", text: $username)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .autocapitalization(.none)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("표시 이름")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("표시할 이름 입력", text: $displayName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("이메일")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("이메일 입력", text: $email)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("비밀번호")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        Group {
                            if showPassword {
                                TextField("비밀번호 입력", text: $password)
                            } else {
                                SecureField("비밀번호 입력", text: $password)
                            }
                        }
                        
                        Button(action: {
                            showPassword.toggle()
                        }) {
                            Image(systemName: showPassword ? "eye.slash" : "eye")
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("비밀번호 확인")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    HStack {
                        Group {
                            if showConfirmPassword {
                                TextField("비밀번호 다시 입력", text: $confirmPassword)
                            } else {
                                SecureField("비밀번호 다시 입력", text: $confirmPassword)
                            }
                        }
                        
                        Button(action: {
                            showConfirmPassword.toggle()
                        }) {
                            Image(systemName: showConfirmPassword ? "eye.slash" : "eye")
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
                
                Button(action: {
                    authManager.signupWithEmail(
                        username: username,
                        displayName: displayName,
                        email: email,
                        password: password
                    )
                }) {
                    HStack {
                        if authManager.isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Text("회원가입")
                                .font(.headline)
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 50)
                    .background(
                        LinearGradient(
                            colors: [.purple, .blue],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(!isFormValid || authManager.isLoading)
                
                if let errorMessage = authManager.errorMessage {
                    Text(errorMessage)
                        .foregroundColor(.red)
                        .font(.caption)
                        .multilineTextAlignment(.center)
                }
            }
            .padding(.horizontal, 20)
        }
    }
    
    private var isFormValid: Bool {
        !username.isEmpty &&
        !displayName.isEmpty &&
        !email.isEmpty &&
        !password.isEmpty &&
        password == confirmPassword &&
        password.count >= 6
    }
}
```

#### Views/ChatsListView.swift
```swift
//
//  ChatsListView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ChatsListView: View {
    @EnvironmentObject var chatManager: ChatManager
    @State private var searchText = ""
    @State private var showingCreateChat = false
    
    var filteredChatRooms: [ChatRoom] {
        if searchText.isEmpty {
            return chatManager.chatRooms
        } else {
            return chatManager.chatRooms.filter { chatRoom in
                chatRoom.name.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .foregroundColor(.secondary)
                        
                        TextField("채팅방 검색", text: $searchText)
                            .textFieldStyle(PlainTextFieldStyle())
                    }
                    .padding(8)
                    .background(Color(.systemGray6))
                    .cornerRadius(10)
                    
                    Button("새 채팅") {
                        showingCreateChat = true
                    }
                    .foregroundColor(.purple)
                }
                .padding()
                
                if !chatManager.isConnected {
                    HStack {
                        Image(systemName: "wifi.slash")
                            .foregroundColor(.red)
                        Text("연결 중...")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 8)
                }
                
                List {
                    ForEach(filteredChatRooms) { chatRoom in
                        NavigationLink(destination: ChatRoomView(chatRoom: chatRoom)) {
                            ChatRoomRowView(chatRoom: chatRoom)
                        }
                        .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                    }
                }
                .listStyle(PlainListStyle())
                .refreshable {
                    chatManager.loadChatRooms()
                }
            }
            .navigationTitle("채팅")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingCreateChat) {
                CreateChatView()
            }
        }
        .onAppear {
            chatManager.loadChatRooms()
        }
    }
}

struct ChatRoomRowView: View {
    let chatRoom: ChatRoom
    @EnvironmentObject var chatManager: ChatManager
    
    private var unreadCount: Int {
        chatManager.unreadCounts[chatRoom.id] ?? 0
    }
    
    var body: some View {
        HStack(spacing: 12) {
            AsyncImage(url: URL(string: chatRoom.participants.first?.profilePicture ?? "")) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Circle()
                    .fill(LinearGradient(
                        colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ))
                    .overlay(
                        Text(chatRoom.name.prefix(1))
                            .font(.title2)
                            .foregroundColor(.purple)
                    )
            }
            .frame(width: 50, height: 50)
            .clipShape(Circle())
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(chatRoom.name)
                        .font(.headline)
                        .lineLimit(1)
                    
                    Spacer()
                    
                    Text("방금 전")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                HStack {
                    Text(chatRoom.lastMessage?.content ?? "새로운 채팅방입니다")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .lineLimit(2)
                    
                    Spacer()
                    
                    if unreadCount > 0 {
                        Text("\(unreadCount)")
                            .font(.caption)
                            .foregroundColor(.white)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.red)
                            .clipShape(Capsule())
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
}

struct CreateChatView: View {
    @Environment(\.presentationMode) var presentationMode
    @EnvironmentObject var chatManager: ChatManager
    @State private var chatName = ""
    @State private var selectedUsers: Set<Int> = []
    @State private var isGroup = false
    
    var body: some View {
        NavigationView {
            VStack {
                Form {
                    Section(header: Text("채팅방 정보")) {
                        TextField("채팅방 이름", text: $chatName)
                        Toggle("그룹 채팅", isOn: $isGroup)
                    }
                }
            }
            .navigationTitle("새 채팅")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("취소") {
                        presentationMode.wrappedValue.dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("생성") {
                        chatManager.createChatRoom(
                            name: chatName,
                            participantIds: Array(selectedUsers),
                            isGroup: isGroup
                        )
                        presentationMode.wrappedValue.dismiss()
                    }
                    .disabled(chatName.isEmpty)
                }
            }
        }
    }
}
```

#### Views/ChatRoomView.swift
```swift
//
//  ChatRoomView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI

struct ChatRoomView: View {
    let chatRoom: ChatRoom
    @EnvironmentObject var chatManager: ChatManager
    @State private var messageText = ""
    @State private var showingAttachments = false
    @FocusState private var isTextFieldFocused: Bool
    
    var body: some View {
        VStack(spacing: 0) {
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(spacing: 8) {
                        ForEach(chatManager.messages) { message in
                            MessageBubbleView(message: message)
                                .id(message.id)
                        }
                        
                        if !chatManager.typingUsers.isEmpty {
                            TypingIndicatorView(users: Array(chatManager.typingUsers.values))
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                }
                .onTapGesture {
                    isTextFieldFocused = false
                }
                .onChange(of: chatManager.messages.count) { _ in
                    if let lastMessage = chatManager.messages.last {
                        withAnimation(.easeOut(duration: 0.3)) {
                            proxy.scrollTo(lastMessage.id, anchor: .bottom)
                        }
                    }
                }
            }
            
            Divider()
            
            MessageInputView(
                messageText: $messageText,
                showingAttachments: $showingAttachments,
                isTextFieldFocused: $isTextFieldFocused,
                onSendMessage: sendMessage
            )
        }
        .navigationTitle(chatRoom.name)
        .navigationBarTitleDisplayMode(.inline)
        .onAppear {
            chatManager.joinChatRoom(chatRoom)
        }
        .onDisappear {
            chatManager.leaveChatRoom()
        }
        .onChange(of: messageText) { newValue in
            if !newValue.isEmpty {
                chatManager.startTyping()
            } else {
                chatManager.stopTyping()
            }
        }
    }
    
    private func sendMessage() {
        guard !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        chatManager.sendMessage(content: messageText.trimmingCharacters(in: .whitespacesAndNewlines))
        messageText = ""
        chatManager.stopTyping()
    }
}

struct MessageBubbleView: View {
    let message: Message
    @EnvironmentObject var authManager: AuthenticationManager
    
    private var isFromCurrentUser: Bool {
        message.senderId == authManager.currentUser?.id
    }
    
    var body: some View {
        HStack {
            if isFromCurrentUser {
                Spacer()
            }
            
            VStack(alignment: isFromCurrentUser ? .trailing : .leading, spacing: 4) {
                Text(message.content ?? "")
                    .font(.body)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(isFromCurrentUser ? 
                                LinearGradient(colors: [.purple, .blue], startPoint: .topLeading, endPoint: .bottomTrailing) :
                                Color(.systemGray5)
                            )
                    )
                    .foregroundColor(isFromCurrentUser ? .white : .primary)
                
                Text(formatMessageTime(message.createdAt))
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .padding(.horizontal, 4)
            }
            .frame(maxWidth: UIScreen.main.bounds.width * 0.75, alignment: isFromCurrentUser ? .trailing : .leading)
            
            if !isFromCurrentUser {
                Spacer()
            }
        }
    }
    
    private func formatMessageTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }
}

struct MessageInputView: View {
    @Binding var messageText: String
    @Binding var showingAttachments: Bool
    @FocusState.Binding var isTextFieldFocused: Bool
    
    let onSendMessage: () -> Void
    
    var body: some View {
        HStack(alignment: .bottom, spacing: 8) {
            Button(action: {
                showingAttachments = true
            }) {
                Image(systemName: "plus")
                    .font(.title2)
                    .foregroundColor(.purple)
                    .frame(width: 36, height: 36)
                    .background(Circle().fill(Color(.systemGray6)))
            }
            
            HStack(alignment: .bottom, spacing: 8) {
                TextField("메시지 입력...", text: $messageText, axis: .vertical)
                    .textFieldStyle(PlainTextFieldStyle())
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color(.systemGray6))
                    .cornerRadius(20)
                    .focused($isTextFieldFocused)
                    .lineLimit(1...5)
                
                if !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    Button(action: onSendMessage) {
                        Image(systemName: "paperplane.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .frame(width: 36, height: 36)
                            .background(
                                Circle().fill(
                                    LinearGradient(
                                        colors: [.purple, .blue],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                            )
                    }
                }
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .background(Color(.systemBackground))
    }
}

struct TypingIndicatorView: View {
    let users: [User]
    @State private var animationOffset: CGFloat = 0
    
    var body: some View {
        HStack {
            Text("\(users.map(\.displayName).joined(separator: ", "))이 입력 중")
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack(spacing: 4) {
                ForEach(0..<3) { index in
                    Circle()
                        .fill(Color.secondary)
                        .frame(width: 6, height: 6)
                        .offset(y: animationOffset)
                        .animation(
                            Animation.easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                            value: animationOffset
                        )
                }
            }
            
            Spacer()
        }
        .padding(.horizontal)
        .onAppear {
            animationOffset = -4
        }
    }
}
```

### 5. 나머지 뷰들 (요약 버전)

#### Views/ContactsView.swift, SpaceView.swift, ArchiveView.swift, SettingsView.swift



이 뷰들은 연락처 관리, 비즈니스 네트워킹, 파일 아카이브, 설정 기능을 제공하며, 위의 패턴과 동일한 SwiftUI 구조를 따릅니다.

### 6. 유틸리티 및 확장

#### Utils/Constants.swift
```swift
struct Constants {
    static let baseURL = "https://dovie-hello2sangyun.replit.app"
    static let websocketURL = "wss://dovie-hello2sangyun.replit.app/ws"
}
```

#### Extensions/View+Extensions.swift
```swift
import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}
```

### 7. Info.plist 설정

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- 기본 앱 정보 -->
    <key>CFBundleDisplayName</key>
    <string>Dovie Messenger</string>
    
    <!-- 권한 설정 -->
    <key>NSCameraUsageDescription</key>
    <string>사진과 동영상을 촬영하여 메시지로 전송하기 위해 카메라 접근이 필요합니다.</string>
    
    <key>NSPhotoLibraryUsageDescription</key>
    <string>사진과 동영상을 선택하여 메시지로 전송하기 위해 사진 라이브러리 접근이 필요합니다.</string>
    
    <key>NSMicrophoneUsageDescription</key>
    <string>음성 메시지를 녹음하기 위해 마이크 접근이 필요합니다.</string>
    
    <key>NSContactsUsageDescription</key>
    <string>친구를 찾고 연락처를 동기화하기 위해 연락처 접근이 필요합니다.</string>
    
    <!-- 백그라운드 모드 -->
    <key>UIBackgroundModes</key>
    <array>
        <string>background-processing</string>
        <string>remote-notification</string>
        <string>background-fetch</string>
    </array>
    
    <!-- URL 스키마 -->
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLName</key>
            <string>com.dovie.messenger</string>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>dovie</string>
            </array>
        </dict>
    </array>
</dict>
</plist>
```

## 📋 Xcode 프로젝트 설정 가이드

### 1. 새 프로젝트 생성
- Xcode에서 "Create a new Xcode project"
- iOS > App 선택
- Product Name: "DovieMessenger"
- Interface: SwiftUI
- Language: Swift

### 2. 파일 구조 생성
각 폴더를 만들고 위의 Swift 파일들을 순서대로 추가합니다.

### 3. Swift Package Dependencies 추가
프로젝트 설정에서 다음 패키지들을 추가하세요:
- Google Sign-In SDK (Google 로그인용)
- Facebook SDK (Facebook 로그인용)

### 4. 실행 및 테스트
- iOS 시뮬레이터에서 앱 실행
- Replit 서버와의 API 연동 테스트
- WebSocket 실시간 통신 확인

## 🔥 **완전한 나머지 Views 코드**

### Views/ContactsView.swift
```swift
//
//  ContactsView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import Combine

struct ContactsView: View {
    @State private var contacts: [Contact] = []
    @State private var searchText = ""
    @State private var showingAddContact = false
    @State private var showingQRScanner = false
    @State private var selectedSegment = 0
    @State private var isLoading = false
    @State private var cancellables = Set<AnyCancellable>()
    
    private let segments = ["전체", "즐겨찾기", "차단됨"]
    
    var filteredContacts: [Contact] {
        let filtered = contacts.filter { contact in
            let matchesSearch = searchText.isEmpty || 
                contact.contactUser?.displayName.localizedCaseInsensitiveContains(searchText) == true ||
                contact.contactUser?.username.localizedCaseInsensitiveContains(searchText) == true
            
            switch selectedSegment {
            case 1: return matchesSearch && contact.isFavorite
            case 2: return matchesSearch && contact.isBlocked
            default: return matchesSearch && !contact.isBlocked
            }
        }
        
        return filtered.sorted { first, second in
            if first.isPinned != second.isPinned { return first.isPinned }
            if first.isFavorite != second.isFavorite { return first.isFavorite }
            return first.contactUser?.displayName ?? "" < second.contactUser?.displayName ?? ""
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                ContactSearchBar(text: $searchText)
                    .padding()
                
                Picker("연락처 필터", selection: $selectedSegment) {
                    ForEach(0..<segments.count, id: \.self) { index in
                        Text(segments[index]).tag(index)
                    }
                }
                .pickerStyle(SegmentedPickerStyle())
                .padding(.horizontal)
                .padding(.bottom)
                
                ContactQuickActions(
                    onAddContact: { showingAddContact = true },
                    onQRScan: { showingQRScanner = true }
                )
                .padding(.horizontal)
                .padding(.bottom)
                
                if isLoading {
                    Spacer()
                    ProgressView("연락처를 불러오는 중...")
                    Spacer()
                } else if filteredContacts.isEmpty {
                    ContactEmptyView(selectedSegment: selectedSegment)
                } else {
                    List {
                        ForEach(filteredContacts) { contact in
                            ContactRowView(contact: contact) { loadContacts() }
                        }
                        .onDelete(perform: deleteContacts)
                    }
                    .listStyle(PlainListStyle())
                    .refreshable { loadContacts() }
                }
            }
            .navigationTitle("연락처")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingAddContact) {
                AddContactView { loadContacts() }
            }
            .sheet(isPresented: $showingQRScanner) {
                QRScannerView { userInfo in addContactFromQR(userInfo) }
            }
        }
        .onAppear { loadContacts() }
    }
    
    private func loadContacts() {
        isLoading = true
        APIService.shared.request<[Contact]>(endpoint: "/api/contacts", method: .GET)
            .sink(
                receiveCompletion: { completion in
                    isLoading = false
                    if case .failure(let error) = completion { print("연락처 로드 실패: \(error)") }
                },
                receiveValue: { loadedContacts in contacts = loadedContacts }
            )
            .store(in: &cancellables)
    }
    
    private func deleteContacts(at offsets: IndexSet) {
        let contactsToDelete = offsets.map { filteredContacts[$0] }
        for contact in contactsToDelete { deleteContact(contact) }
    }
    
    private func deleteContact(_ contact: Contact) {
        APIService.shared.request<EmptyResponse>(endpoint: "/api/contacts/\(contact.id)", method: .DELETE)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in contacts.removeAll { $0.id == contact.id } }
            )
            .store(in: &cancellables)
    }
    
    private func addContactFromQR(_ userInfo: [String: Any]) {
        guard let userId = userInfo["userId"] as? Int else { return }
        let body = ["contactUserId": userId]
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else { return }
        
        APIService.shared.request<Contact>(endpoint: "/api/contacts", method: .POST, body: bodyData)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { newContact in contacts.append(newContact) }
            )
            .store(in: &cancellables)
    }
}

struct ContactSearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass").foregroundColor(.secondary)
            TextField("연락처 검색", text: $text).textFieldStyle(PlainTextFieldStyle())
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill").foregroundColor(.secondary)
                }
            }
        }
        .padding(8)
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
}

struct ContactQuickActions: View {
    let onAddContact: () -> Void
    let onQRScan: () -> Void
    
    var body: some View {
        HStack(spacing: 16) {
            Button(action: onAddContact) {
                HStack {
                    Image(systemName: "person.badge.plus")
                    Text("연락처 추가")
                }
                .font(.subheadline)
                .foregroundColor(.white)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(LinearGradient(colors: [.purple, .blue], startPoint: .leading, endPoint: .trailing))
                .cornerRadius(20)
            }
            
            Button(action: onQRScan) {
                HStack {
                    Image(systemName: "qrcode.viewfinder")
                    Text("QR 스캔")
                }
                .font(.subheadline)
                .foregroundColor(.purple)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(Color.purple.opacity(0.1))
                .cornerRadius(20)
            }
            Spacer()
        }
    }
}

struct ContactRowView: View {
    let contact: Contact
    let onUpdate: () -> Void
    @State private var showingContactDetail = false
    
    var body: some View {
        HStack(spacing: 12) {
            AsyncImage(url: URL(string: contact.contactUser?.profilePicture ?? "")) { image in
                image.resizable().aspectRatio(contentMode: .fill)
            } placeholder: {
                Circle()
                    .fill(LinearGradient(colors: [.purple.opacity(0.3), .blue.opacity(0.3)], startPoint: .topLeading, endPoint: .bottomTrailing))
                    .overlay(Text(contact.contactUser?.initials ?? "?").font(.title2).foregroundColor(.purple))
            }
            .frame(width: 50, height: 50)
            .clipShape(Circle())
            .overlay(Circle().stroke(Color.green, lineWidth: contact.contactUser?.isOnline == true ? 3 : 0))
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(contact.contactUser?.displayName ?? "Unknown").font(.headline).lineLimit(1)
                    if contact.isPinned { Image(systemName: "pin.fill").foregroundColor(.orange).font(.caption) }
                    if contact.isFavorite { Image(systemName: "star.fill").foregroundColor(.yellow).font(.caption) }
                    Spacer()
                    Button(action: { showingContactDetail = true }) {
                        Image(systemName: "ellipsis").foregroundColor(.secondary)
                    }
                }
                Text(contact.contactUser?.displayUsername ?? "").font(.subheadline).foregroundColor(.secondary)
                if let businessName = contact.contactUser?.businessName {
                    Text(businessName)
                        .font(.caption)
                        .foregroundColor(.purple)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.purple.opacity(0.1))
                        .cornerRadius(4)
                }
            }
        }
        .padding(.vertical, 4)
        .sheet(isPresented: $showingContactDetail) {
            ContactDetailView(contact: contact, onUpdate: onUpdate)
        }
    }
}

struct ContactEmptyView: View {
    let selectedSegment: Int
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: getEmptyStateIcon()).font(.system(size: 60)).foregroundColor(.secondary)
            Text(getEmptyStateTitle()).font(.title2).fontWeight(.medium)
            Text(getEmptyStateMessage()).font(.body).foregroundColor(.secondary).multilineTextAlignment(.center).padding(.horizontal, 40)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private func getEmptyStateIcon() -> String {
        switch selectedSegment {
        case 1: return "star"
        case 2: return "hand.raised"
        default: return "person.2"
        }
    }
    
    private func getEmptyStateTitle() -> String {
        switch selectedSegment {
        case 1: return "즐겨찾기가 없습니다"
        case 2: return "차단된 연락처가 없습니다"
        default: return "연락처가 없습니다"
        }
    }
    
    private func getEmptyStateMessage() -> String {
        switch selectedSegment {
        case 1: return "자주 대화하는 친구들을 즐겨찾기에 추가해보세요."
        case 2: return "차단된 연락처가 없습니다."
        default: return "새로운 친구를 추가하거나 QR 코드를 스캔해보세요."
        }
    }
}
```

### Views/SpaceView.swift
```swift
//
//  SpaceView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import Combine

struct SpaceView: View {
    @State private var posts: [BusinessPost] = []
    @State private var isLoading = false
    @State private var showingCreatePost = false
    @State private var selectedTab = 0
    @State private var cancellables = Set<AnyCancellable>()
    @EnvironmentObject var authManager: AuthenticationManager
    
    private let tabs = ["피드", "내 게시물", "저장됨"]
    
    var filteredPosts: [BusinessPost] {
        switch selectedTab {
        case 1: return posts.filter { $0.userId == authManager.currentUser?.id }
        case 2: return posts.filter { $0.isLiked }
        default: return posts
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                Picker("피드 종류", selection: $selectedTab) {
                    ForEach(0..<tabs.count, id: \.self) { index in
                        Text(tabs[index]).tag(index)
                    }
                }
                .pickerStyle(SegmentedPickerStyle())
                .padding()
                
                if isLoading {
                    Spacer()
                    ProgressView("로딩 중...")
                    Spacer()
                } else if filteredPosts.isEmpty {
                    SpaceEmptyView(selectedTab: selectedTab)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 16) {
                            ForEach(filteredPosts) { post in
                                BusinessPostView(post: post) { loadPosts() }
                            }
                        }
                        .padding()
                    }
                    .refreshable { loadPosts() }
                }
            }
            .navigationTitle("비즈니스 스페이스")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: { showingCreatePost = true }) {
                        Image(systemName: "plus").font(.title2)
                    }
                }
            }
            .sheet(isPresented: $showingCreatePost) {
                CreatePostView { loadPosts() }
            }
        }
        .onAppear { loadPosts() }
    }
    
    private func loadPosts() {
        isLoading = true
        APIService.shared.request<[BusinessPost]>(endpoint: "/api/business-posts", method: .GET)
            .sink(
                receiveCompletion: { completion in
                    isLoading = false
                    if case .failure(let error) = completion { print("게시물 로드 실패: \(error)") }
                },
                receiveValue: { loadedPosts in posts = loadedPosts }
            )
            .store(in: &cancellables)
    }
}

struct BusinessPostView: View {
    @State var post: BusinessPost
    let onUpdate: () -> Void
    @State private var showingComments = false
    @State private var cancellables = Set<AnyCancellable>()
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 12) {
                AsyncImage(url: URL(string: post.author?.profilePicture ?? "")) { image in
                    image.resizable().aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle().fill(Color.purple.opacity(0.3))
                        .overlay(Text(post.author?.initials ?? "?").foregroundColor(.purple))
                }
                .frame(width: 50, height: 50)
                .clipShape(Circle())
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(post.author?.displayName ?? "Unknown").font(.headline)
                    Text(formatDate(post.createdAt)).font(.caption).foregroundColor(.secondary)
                    if let businessName = post.author?.businessName {
                        Text(businessName).font(.caption).foregroundColor(.purple)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 2)
                            .background(Color.purple.opacity(0.1))
                            .cornerRadius(4)
                    }
                }
                Spacer()
                Button(action: {}) { Image(systemName: "ellipsis").foregroundColor(.secondary) }
            }
            
            Text(post.content).font(.body).fixedSize(horizontal: false, vertical: true)
            
            if let imageUrl = post.imageUrl {
                AsyncImage(url: URL(string: imageUrl)) { image in
                    image.resizable().aspectRatio(contentMode: .fit)
                } placeholder: {
                    Rectangle().fill(Color.gray.opacity(0.3)).frame(height: 200)
                        .overlay(ProgressView())
                }
                .cornerRadius(12)
            }
            
            HStack(spacing: 24) {
                Button(action: { toggleLike() }) {
                    HStack(spacing: 4) {
                        Image(systemName: post.isLiked ? "heart.fill" : "heart")
                            .foregroundColor(post.isLiked ? .red : .secondary)
                        Text("\(post.likesCount)")
                            .foregroundColor(.secondary)
                    }
                }
                
                Button(action: { showingComments = true }) {
                    HStack(spacing: 4) {
                        Image(systemName: "message").foregroundColor(.secondary)
                        Text("\(post.commentsCount)").foregroundColor(.secondary)
                    }
                }
                
                Button(action: {}) {
                    Image(systemName: "square.and.arrow.up").foregroundColor(.secondary)
                }
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "bookmark").foregroundColor(.secondary)
                }
            }
            .padding(.top, 8)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .sheet(isPresented: $showingComments) {
            CommentsView(postId: post.id)
        }
    }
    
    private func toggleLike() {
        let newLikeStatus = !post.isLiked
        post.isLiked = newLikeStatus
        post.likesCount += newLikeStatus ? 1 : -1
        
        let body = ["isLiked": newLikeStatus]
        guard let bodyData = try? JSONSerialization.data(withJSONObject: body) else { return }
        
        APIService.shared.request<EmptyResponse>(endpoint: "/api/business-posts/\(post.id)/like", method: .POST, body: bodyData)
            .sink(receiveCompletion: { _ in }, receiveValue: { _ in onUpdate() })
            .store(in: &cancellables)
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.dateTimeStyle = .named
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}

struct SpaceEmptyView: View {
    let selectedTab: Int
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: getEmptyIcon()).font(.system(size: 60)).foregroundColor(.secondary)
            Text(getEmptyTitle()).font(.title2).fontWeight(.medium)
            Text(getEmptyMessage()).font(.body).foregroundColor(.secondary).multilineTextAlignment(.center).padding(.horizontal, 40)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private func getEmptyIcon() -> String {
        switch selectedTab {
        case 1: return "doc.text"
        case 2: return "bookmark"
        default: return "briefcase"
        }
    }
    
    private func getEmptyTitle() -> String {
        switch selectedTab {
        case 1: return "작성한 게시물이 없습니다"
        case 2: return "저장된 게시물이 없습니다"
        default: return "게시물이 없습니다"
        }
    }
    
    private func getEmptyMessage() -> String {
        switch selectedTab {
        case 1: return "첫 번째 비즈니스 게시물을 작성해보세요."
        case 2: return "관심 있는 게시물을 저장해보세요."
        default: return "비즈니스 네트워킹을 시작해보세요."
        }
    }
}
```

### Views/ArchiveView.swift
```swift
//
//  ArchiveView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import Combine

enum FileCategory: String, CaseIterable {
    case all = "전체"
    case image = "이미지"
    case video = "동영상"
    case audio = "오디오"
    case document = "문서"
    case other = "기타"
    
    var icon: String {
        switch self {
        case .all: return "folder"
        case .image: return "photo"
        case .video: return "video"
        case .audio: return "music.note"
        case .document: return "doc.text"
        case .other: return "questionmark.folder"
        }
    }
}

struct ArchivedFile: Identifiable, Codable {
    let id: Int
    let originalName: String
    let fileName: String
    let fileSize: Int
    let fileType: String
    let filePath: String
    let category: FileCategory
    let tags: [String]
    let createdAt: Date
    let chatRoomId: Int?
    let senderId: Int?
    
    var sizeFormatted: String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB, .useGB]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(fileSize))
    }
}

struct ArchiveView: View {
    @State private var files: [ArchivedFile] = []
    @State private var searchText = ""
    @State private var selectedCategory: FileCategory = .all
    @State private var isLoading = false
    @State private var cancellables = Set<AnyCancellable>()
    
    var filteredFiles: [ArchivedFile] {
        let filtered = files.filter { file in
            let matchesSearch = searchText.isEmpty || 
                file.originalName.localizedCaseInsensitiveContains(searchText) ||
                file.tags.contains { $0.localizedCaseInsensitiveContains(searchText) }
            
            let matchesCategory = selectedCategory == .all || file.category == selectedCategory
            return matchesSearch && matchesCategory
        }
        
        return filtered.sorted { $0.createdAt > $1.createdAt }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                ArchiveSearchBar(text: $searchText)
                    .padding()
                
                CategorySelector(selectedCategory: $selectedCategory)
                    .padding(.horizontal)
                
                if isLoading {
                    Spacer()
                    ProgressView("파일을 불러오는 중...")
                    Spacer()
                } else if filteredFiles.isEmpty {
                    ArchiveEmptyView(selectedCategory: selectedCategory)
                } else {
                    ScrollView {
                        LazyVGrid(columns: [
                            GridItem(.flexible()),
                            GridItem(.flexible())
                        ], spacing: 16) {
                            ForEach(filteredFiles) { file in
                                FileCardView(file: file) { loadFiles() }
                            }
                        }
                        .padding()
                    }
                    .refreshable { loadFiles() }
                }
            }
            .navigationTitle("아카이브")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button("파일 업로드") { /* 파일 업로드 */ }
                        Button("카메라") { /* 카메라 촬영 */ }
                        Button("사진 라이브러리") { /* 사진 선택 */ }
                    } label: {
                        Image(systemName: "plus").font(.title2)
                    }
                }
            }
        }
        .onAppear { loadFiles() }
    }
    
    private func loadFiles() {
        isLoading = true
        APIService.shared.request<[ArchivedFile]>(endpoint: "/api/archive", method: .GET)
            .sink(
                receiveCompletion: { completion in
                    isLoading = false
                    if case .failure(let error) = completion { print("파일 로드 실패: \(error)") }
                },
                receiveValue: { loadedFiles in files = loadedFiles }
            )
            .store(in: &cancellables)
    }
}

struct ArchiveSearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass").foregroundColor(.secondary)
            TextField("파일 검색", text: $text).textFieldStyle(PlainTextFieldStyle())
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill").foregroundColor(.secondary)
                }
            }
        }
        .padding(8)
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
}

struct CategorySelector: View {
    @Binding var selectedCategory: FileCategory
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                ForEach(FileCategory.allCases, id: \.self) { category in
                    CategoryChip(
                        category: category,
                        isSelected: selectedCategory == category
                    ) {
                        selectedCategory = category
                    }
                }
            }
            .padding(.horizontal)
        }
    }
}

struct CategoryChip: View {
    let category: FileCategory
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                Image(systemName: category.icon).font(.caption)
                Text(category.rawValue).font(.subheadline)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(
                isSelected ? 
                LinearGradient(colors: [.purple, .blue], startPoint: .leading, endPoint: .trailing) :
                Color(.systemGray6)
            )
            .foregroundColor(isSelected ? .white : .primary)
            .cornerRadius(16)
        }
    }
}

struct FileCardView: View {
    let file: ArchivedFile
    let onUpdate: () -> Void
    @State private var showingDetail = false
    @State private var showingShareSheet = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            FilePreviewView(file: file)
                .frame(height: 120)
                .cornerRadius(8)
                .onTapGesture { showingDetail = true }
            
            VStack(alignment: .leading, spacing: 4) {
                Text(file.originalName)
                    .font(.caption)
                    .fontWeight(.medium)
                    .lineLimit(2)
                
                HStack {
                    Text(file.sizeFormatted)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    
                    Spacer()
                    
                    Menu {
                        Button("공유") { showingShareSheet = true }
                        Button("다운로드") { downloadFile() }
                        Button("삭제", role: .destructive) { deleteFile() }
                    } label: {
                        Image(systemName: "ellipsis")
                            .foregroundColor(.secondary)
                    }
                }
                
                if !file.tags.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 4) {
                            ForEach(file.tags, id: \.self) { tag in
                                Text("#\(tag)")
                                    .font(.caption2)
                                    .foregroundColor(.purple)
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(Color.purple.opacity(0.1))
                                    .cornerRadius(4)
                            }
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .sheet(isPresented: $showingDetail) {
            FileDetailView(file: file, onUpdate: onUpdate)
        }
    }
    
    private func downloadFile() {
        // 파일 다운로드 구현
    }
    
    private func deleteFile() {
        APIService.shared.request<EmptyResponse>(endpoint: "/api/archive/\(file.id)", method: .DELETE)
            .sink(receiveCompletion: { _ in }, receiveValue: { _ in onUpdate() })
            .store(in: &Set<AnyCancellable>())
    }
}

struct FilePreviewView: View {
    let file: ArchivedFile
    
    var body: some View {
        Group {
            if file.category == .image {
                AsyncImage(url: URL(string: file.filePath)) { image in
                    image.resizable().aspectRatio(contentMode: .fill)
                } placeholder: {
                    Rectangle().fill(Color.gray.opacity(0.3)).overlay(ProgressView())
                }
            } else {
                Rectangle()
                    .fill(LinearGradient(colors: [.purple.opacity(0.3), .blue.opacity(0.3)], startPoint: .topLeading, endPoint: .bottomTrailing))
                    .overlay(
                        VStack {
                            Image(systemName: file.category.icon)
                                .font(.title)
                                .foregroundColor(.purple)
                            Text(file.fileType.uppercased())
                                .font(.caption)
                                .foregroundColor(.purple)
                        }
                    )
            }
        }
    }
}

struct ArchiveEmptyView: View {
    let selectedCategory: FileCategory
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: selectedCategory.icon)
                .font(.system(size: 60))
                .foregroundColor(.secondary)
            
            Text(getEmptyTitle())
                .font(.title2)
                .fontWeight(.medium)
            
            Text(getEmptyMessage())
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private func getEmptyTitle() -> String {
        if selectedCategory == .all {
            return "저장된 파일이 없습니다"
        } else {
            return "\(selectedCategory.rawValue) 파일이 없습니다"
        }
    }
    
    private func getEmptyMessage() -> String {
        return "채팅에서 공유한 파일들이 여기에 자동으로 저장됩니다."
    }
}
```

### Views/SettingsView.swift
```swift
//
//  SettingsView.swift
//  DovieMessenger
//
//  Created by Dovie Team
//

import SwiftUI
import Combine

struct SettingsView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    @State private var showingProfile = false
    @State private var showingPrivacy = false
    @State private var showingNotifications = false
    @State private var showingAbout = false
    @State private var showingLogoutAlert = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    ProfileSectionView()
                        .onTapGesture { showingProfile = true }
                }
                
                Section("일반") {
                    SettingsRow(icon: "bell", title: "알림", subtitle: "푸시 알림 설정") {
                        showingNotifications = true
                    }
                    
                    SettingsRow(icon: "lock", title: "개인정보 보호", subtitle: "보안 및 개인정보") {
                        showingPrivacy = true
                    }
                    
                    SettingsRow(icon: "paintbrush", title: "테마", subtitle: "화면 모드 설정") {
                        // 테마 설정
                    }
                    
                    SettingsRow(icon: "globe", title: "언어", subtitle: "앱 언어 설정") {
                        // 언어 설정
                    }
                }
                
                Section("저장 공간") {
                    SettingsRow(icon: "externaldrive", title: "저장 공간 관리", subtitle: "캐시 및 다운로드 관리") {
                        // 저장 공간 관리
                    }
                    
                    SettingsRow(icon: "trash", title: "캐시 삭제", subtitle: "임시 파일 삭제") {
                        // 캐시 삭제
                    }
                }
                
                Section("지원") {
                    SettingsRow(icon: "questionmark.circle", title: "도움말", subtitle: "자주 묻는 질문") {
                        // 도움말
                    }
                    
                    SettingsRow(icon: "envelope", title: "문의하기", subtitle: "버그 신고 및 제안") {
                        // 문의하기
                    }
                    
                    SettingsRow(icon: "info.circle", title: "앱 정보", subtitle: "버전 및 라이선스") {
                        showingAbout = true
                    }
                }
                
                Section {
                    Button(action: { showingLogoutAlert = true }) {
                        HStack {
                            Image(systemName: "arrow.backward.square")
                                .foregroundColor(.red)
                            Text("로그아웃")
                                .foregroundColor(.red)
                        }
                    }
                }
            }
            .navigationTitle("설정")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingProfile) { ProfileEditView() }
            .sheet(isPresented: $showingPrivacy) { PrivacySettingsView() }
            .sheet(isPresented: $showingNotifications) { NotificationSettingsView() }
            .sheet(isPresented: $showingAbout) { AboutView() }
            .alert("로그아웃", isPresented: $showingLogoutAlert) {
                Button("취소", role: .cancel) { }
                Button("로그아웃", role: .destructive) { authManager.logout() }
            } message: {
                Text("정말로 로그아웃하시겠습니까?")
            }
        }
    }
}

struct ProfileSectionView: View {
    @EnvironmentObject var authManager: AuthenticationManager
    
    var body: some View {
        HStack(spacing: 16) {
            AsyncImage(url: URL(string: authManager.currentUser?.profilePicture ?? "")) { image in
                image.resizable().aspectRatio(contentMode: .fill)
            } placeholder: {
                Circle()
                    .fill(LinearGradient(colors: [.purple.opacity(0.3), .blue.opacity(0.3)], startPoint: .topLeading, endPoint: .bottomTrailing))
                    .overlay(Text(authManager.currentUser?.initials ?? "?").font(.title).foregroundColor(.purple))
            }
            .frame(width: 60, height: 60)
            .clipShape(Circle())
            
            VStack(alignment: .leading, spacing: 4) {
                Text(authManager.currentUser?.displayName ?? "Unknown").font(.headline)
                Text(authManager.currentUser?.displayUsername ?? "").font(.subheadline).foregroundColor(.secondary)
                if let businessName = authManager.currentUser?.businessName {
                    Text(businessName)
                        .font(.caption)
                        .foregroundColor(.purple)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.purple.opacity(0.1))
                        .cornerRadius(4)
                }
            }
            Spacer()
            Image(systemName: "chevron.right").foregroundColor(.secondary)
        }
        .padding(.vertical, 8)
    }
}

struct SettingsRow: View {
    let icon: String
    let title: String
    let subtitle: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                Image(systemName: icon)
                    .foregroundColor(.purple)
                    .frame(width: 24, height: 24)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(title).font(.body).foregroundColor(.primary)
                    Text(subtitle).font(.caption).foregroundColor(.secondary)
                }
                Spacer()
                Image(systemName: "chevron.right").foregroundColor(.secondary).font(.caption)
            }
            .padding(.vertical, 4)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
```

## 🔧 **빠진 중요 파일들**

### 1. **프로젝트에 추가해야 할 파일들:**

#### AppDelegate.swift (푸시 알림용)
```swift
import UIKit
import UserNotifications

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        return true
    }
    
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        PushNotificationManager.shared.registerDeviceToken(deviceToken)
    }
    
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("푸시 알림 등록 실패: \(error)")
    }
}
```

#### 추가 Utils 파일들:
- **DateUtils.swift**: 날짜 포맷팅 헬퍼
- **NetworkUtils.swift**: 네트워크 연결 상태 확인
- **Constants.swift**: 앱 전체 상수들

### 2. **Swift Package Dependencies 추가:**

Xcode에서 다음 패키지들을 추가하세요:

```
// Google Sign-In (Google 로그인용)
https://github.com/google/GoogleSignIn-iOS

// Facebook SDK (Facebook 로그인용)  
https://github.com/facebook/facebook-ios-sdk
```

### 3. **Info.plist 권한 설정:**

위에 제공된 Info.plist 설정을 프로젝트에 복사하세요.

이제 완전한 네이티브 iOS 메신저 앱을 구현하며, Replit 백엔드 서버와 완벽하게 연동됩니다.